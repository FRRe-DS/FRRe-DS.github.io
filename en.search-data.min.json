[{"id":0,"href":"/trabajos-practicos/tp_01/","title":"Trabajo Pr√°ctico N√∫mero 1","parent":"Trabajos Pr√°cticos","content":"Objetivos    Que el alumno logre:\n Adquirir habilidades y conocimiento de las principales caracter√≠sticas y capacidades de las diferentes tecnolog√≠as y herramientas para el desarrollo y construcci√≥n de aplicaciones inform√°ticas actuales. Aplicar criterios de selecci√≥n de software en base a caracter√≠sticas y necesidades de un sistema. Adquirir habilidades en b√∫squeda y organizaci√≥n de informaci√≥n.   Modalidad de Desarrollo    Grupal: en grupos de entre 4 y 6 alumnos.\nFormato de Presentaci√≥n    Individual con coloquio en m√°quina e informe impreso y digital (formato .odt .doc .pdf).\nFecha de Entrega    15/04/2021  Exposici√≥n Grupal    16/04/2021  Contenido del Informe de Presentaci√≥n     Formato de hoja: A4. Car√°tula: Nombre de la materia, a√±o de cursado, n√∫mero de grupo, nombre completo de los integrantes. Correo electr√≥nico de cada integrante. √çndice de contenidos: √≠ndice tem√°tico de contenidos, organizado por lenguaje o herramientas de programaci√≥n. Informe comparativo: Descripci√≥n de cada lenguaje evaluando cada una de las caracter√≠sticas seleccionadas. Extensi√≥n de No m√°s de tres p√°ginas por herramienta. Cuadro Comparativo: Cuadro sin√≥ptico resumen de doble entrada (caracter√≠stica x herramienta) conteniendo los principales √≠tems y cuantificaciones. Bibliograf√≠a: Citaci√≥n de Fuentes de referencia de la documentaci√≥n o bibliograf√≠a consultada.  Aspectos de Evaluaci√≥n     Cumplimiento de actividades propuestas y fechas indicadas. Investigaci√≥n y desarrollo del material. Presentaci√≥n.  La correcta redacci√≥n de los textos, su ortograf√≠a y puntuaci√≥n. La relaci√≥n y coherencia en cuanto a los tipos de letras utilizados para los cap√≠tulos, partes o secciones componentes del informe.    Actividad 1: Informe de investigaci√≥n de Sistema de Control de Versiones     Investigar y elaborar un breve informe de sistemas de control de versiones disponibles en el mercado, tanto del tipo centralizado como descentralizado (entre 5 y 8, ejemplo git, mercurial, svn, cvs, bitkeeper, etc). Indicar los siguientes √≠tems:   Tipos de versionado soportados. Licencia Costo (gratuito / propietario) Quien lo mantiene. Plataformas soportadas (Windows, Unix, etc) Extras  Elaborar un cuadro comparativo que resuma los puntos antes mencionados Realizar el mismo cuadro con plataformas comerciales de sistemas de control de versiones (entre 5 y 8, por ejemplo Atlassian, Github, etc) agregando la columna sistemas de control de versiones que soporta mencionadas en el punto anterior. Adem√°s mencionar que herramientas adicionales incluyen (por ejemplo wiki, herramientas de gesti√≥n de proyectos, etc).    Actividad 2: An√°lisis y utilizaci√≥n de un Sistema de Control de Versiones Centralizado     Investigar un SCV Centralizado y explicar las principales caracter√≠sticas brevemente. Enumerar ventajas y desventajas, y comparaci√≥n con SCV Descentralizados (cuadro comparativo). Seleccionar un servidor que se encuentre en la nube/web gratuito para realizar un ejemplo. Realizar un ejemplo iniciar el repositorio, clonarlo, modificarlo y generar conflictos, crear ramas y realizar merge de las mismas con el trunk principal, en un peque√±o equipo por lo menos 3 miembros del grupo. Utilizar de ser necesario una herramienta cliente (gr√°fico o consola) o IDE. Documentar el ejemplo con capturas de commits de los miembros del equipo sobre un mismo archivo y otro ejemplo de branch y merge.  Actividad 3: Actividad pr√°ctica sobre Git y Github    Utilizando Git por l√≠nea de comandos o desde la Web de Github (seg√∫n corresponda) realizar el siguiente ejercicio (ir evidenciando documentando los pasos ver nota al final):\n Un miembro del equipo va a clonar el siguiente repositorio y va a crear una rama para el grupo (la misma va a tener la forma GX/principal donde X es el n√∫mero de grupo). En su repositorio local el usuario va a crear un va a crear una carpeta de grupo (grupoX) y dentro de la misma va crear un proyecto en Node.js. Commitear los cambios en el repositorio y subir la rama al servidor remoto. Les dejo un link de ayuda:  Link 1 Link 2   Una vez creada la rama del grupo en el servidor uno de los miembros del grupo va hacer un fork de la rama. Clona el fork, va a insertar una funci√≥n que imprime en un label una entrada de pantalla, commit.\u0026gt; push y pull request al repositorio del grupo. Los dem√°s miembros del grupo: Clonar el repositorio y toman la rama del grupo. A partir de la rama del grupo, crean una rama personal (gXiniciales grupo X e 2 iniciales) donde realizar una modificaci√≥n en c√≥digo (insertar una funci√≥n que transforme el formato de un texto, que calcule una suma y la muestre en pantalla, etc) y realizar un commit y push, (Generar un conflicto y resolverlo). Ponerse de acuerdo en el grupo. Realizar un pull request de la rama personal a la principal de grupo. Aceptar / confirmar los pull request en la web, obtener a la funcionalidad completa del programa. Generar un tag para la versi√≥n con el nombre gX-V-1.0.0 X n√∫mero de grupo (por l√≠nea de comando) y subir al repositorio remoto. Realizar un cambio en el programa sobre la rama principal del grupo y subir el cambio (que introduce un error al programa). Crear una rama a partir del tag creado y subir la rama al repo remoto y crear un pull request a la rama principal. Aceptar / Confirmar el pull request creado en el paso anterior (corregir el error).  "},{"id":1,"href":"/trabajos-practicos/tp-final/apis/","title":"Definici√≥n de APIs","parent":"Trabajo Pr√°ctico Final","content":"Objetivos    Este documento define las interfaces entre los diferentes sub-sistemas del TP Final.\nMinisterio de Desarrollo Productivo üìã      Esquemas de Datos\n  Reportes\nconst reporteSchema = new Schema\u0026lt;IReport\u0026gt;({ infoEmpresa: { type: Schema.Types.ObjectId, ref: \u0026#34;Business\u0026#34;, }, listaRegistro: { type: [ { type: Schema.Types.ObjectId, ref: \u0026#34;Products\u0026#34;, }, ], }, date_upload: { type: Date, default: Date.now(), }, day_limit: { type: Number, default: 10, }, periodo: { year: { type: String, require: true, trim: true, }, month: { type: String, require: true, trim: true, }, }, });   Empresas\nconst businessSchema = new Schema\u0026lt;IBusiness\u0026gt;({ cuit: { type: Number, require: true, trim: true, }, razon_social: { type: String, require: true, trim: true, }, report: { type: [ { type: Schema.Types.ObjectId, ref: \u0026#34;Report\u0026#34;, }, ], }, });   Productos\nconst productsSchema = new Schema\u0026lt;IProduct\u0026gt;({ denominacion: { type: String, require: true, trim: true, }, codigo_ean: { type: Number, require: true, trim: true, }, precio_unidad: { type: Number, require: true, trim: true, }, unidad_medida: { type: String, require: true, trim: true, }, cantidad_prod: { type: Number, require: true, trim: true, }, cantidad_vend: { type: Number, require: true, trim: true, }, report: { type: Schema.Types.ObjectId, ref: \u0026#34;Report\u0026#34;, } }); ```   Usuarios Empresas\nconst userBusinessSchema = new Schema\u0026lt;IUserBusiness\u0026gt;({ cuit: { type: Number, unique: true, trim: true, require: true, min: [11, \u0026#34;El CUIT debe tener 11 digitos\u0026#34;], }, razon_social: { type: String, require: true, trim: true, }, industria: { type: String, require: true, trim: true, }, email: { type: String, unique: true, require: true, trim: true, }, tel: { type: Number, unique: true, require: true, trim: true, }, ciudad: { type: String, require: true, trim: true, }, password: { type: String, require: true, trim: true, minLength: [6, \u0026#34;¬°La constrase√±a debe tener al menos 6 caracteres!\u0026#34;], }, });       Rutas En esta primera entrega solo trabajaremos de forma local, debido a esto se especifican las siguientes rutas\n  Rutas para manipular reportes, todas estas rutas deben llevar en el Header de la petici√≥n el token de validaci√≥n.\n  Obtengo todos los reportes asociados a la empresa autenticada.\n GET localhost:3000/api/reports\n   Cargo un reporte asociado a la empresa autenticada.\n POST localhost:3000/api/reports\n   Actualizo un reporte asociado a la empresa autenticada, se considera solo que se envian nuevos productos. Se pasa por parametro el id del reporte.\n PUT localhost:3000/api/reports/:_id\n   Elimino un reporte asociado a la empresa autenticada. Se pasa por parametro el id del reporte.\n DELETE localhost:3000/api/reports/:_id\n     Acotaci√≥n debido a diferencia de opini√≥n:    Lo que presentan las empresas es una declaracion jurada, por lo que el recurso a exponer en la ruta deber√≠a ser seg√∫n mi entendimiento /declaraciones-juradas, debido a que un reporte es un informe, que por ejemplo podr√≠a ser generado en base a las declaraciones juradas presentadas, adem√°s que en el lenguaje del negocio se lo define expl√≠citamente como \u0026ldquo;declaraci√≥n jurada\u0026rdquo;. Por otro lado estoy trabajando en funcionalidades que me permitan generar registros con procesos estad√≠sticos que permitan al ministerio tomar decisiones acerca de un sector, analizando la relaci√≥n cantidad producida sobre vendida, para poder impulsar las ventas en caso de ser necesario o producir m√°s en caso de escacez de un producto o sector, como ser en el l√°cteo la leche entera. Esto √∫ltimo mencionado ser√≠an reportes generados por sistema en la API ministerio expuesto quiz√° en un ruta como /reportes-de-produccion. De conultar los reportes de produccion, si lo llamaremos as√≠, el ministerio podr√≠a implementar, por ejemplo, una pol√≠tica para un sector \u0026ldquo;x\u0026rdquo; que permita a determinadas empresas que re√∫nan una condici√≥n determinada acceder a una tasa de financiamiento diferencial, debido a que los reportes servir√≠an como soporte para la toma de decisiones. M√°s o menos esto lo hab√≠amos charlado en clase, debido a que lo que quiere el ministerio es reactivar la econom√≠a. Es mi humilde opini√≥n. D\u0026rsquo;Antiochia Conrado/grupo 10\n  Rutas para manipular la autenticaci√≥n de empresas, estas rutas devuelven en el Header el token de autenticaci√≥n necesario para acceder a las rutas arriba mencionadas.\n  Registro una empresa\n POST localhost:3000/api/signup\n   Autentica una empresa\n POST localhost:3000/api/login\n       Ejemplo\n  De la petici√≥n POST a localhost:3000/api/signup\n{ \u0026#34;cuit\u0026#34;: 20391791199, \u0026#34;razon_social\u0026#34;: \u0026#34;SANCOR SA\u0026#34;, \u0026#34;industria\u0026#34;: \u0026#34;Lacteos\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;sancor@gmail.com\u0026#34;, \u0026#34;tel\u0026#34;: 3624771222, \u0026#34;ciudad\u0026#34;: \u0026#34;Resistencia\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;sancorelmejor\u0026#34; }   De la petici√≥n POST a localhost:3000/api/login\n{ \u0026#34;email\u0026#34;: \u0026#34;sancor@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;sancorelmejor\u0026#34; }   De la petici√≥n POST a localhost:3000/api/reports\n{ \u0026#34;infoEmpresa\u0026#34;: { \u0026#34;cuit\u0026#34;: 20391791199, \u0026#34;razon_social\u0026#34;: \u0026#34;SANCOR SA\u0026#34; }, \u0026#34;listaRegistro\u0026#34;: [ { \u0026#34;denominacion\u0026#34;: \u0026#34;Yogurt\u0026#34;, \u0026#34;codigo_ean\u0026#34;: 9523113131251, \u0026#34;precio_unidad\u0026#34;: 1, \u0026#34;unidad_medida\u0026#34;: \u0026#34;Lt\u0026#34;, \u0026#34;cantidad_prod\u0026#34;: 2, \u0026#34;cantidad_vend\u0026#34;: 1 }, { \u0026#34;denominacion\u0026#34;: \u0026#34;Yogurt\u0026#34;, \u0026#34;codigo_ean\u0026#34;: 9217131934313, \u0026#34;precio_unidad\u0026#34;: 1, \u0026#34;unidad_medida\u0026#34;: \u0026#34;Lt\u0026#34;, \u0026#34;cantidad_prod\u0026#34;: 2, \u0026#34;cantidad_vend\u0026#34;: 1 } ], \u0026#34;periodo\u0026#34;: { \u0026#34;year\u0026#34;: \u0026#34;2021\u0026#34;, \u0026#34;month\u0026#34;: \u0026#34;12\u0026#34; } }     Algunas validaciones importantes que deben tener los datos enviados.\n CUIT de 11 digitos. PASSWORD de 6 digitos como minimo. CODIGO EAN de 13 digitos. EMAIL debe tener el formato correcto. example@gmail.com    "},{"id":2,"href":"/trabajos-practicos/tp_02/","title":"Trabajo Pr√°ctico N√∫mero 2","parent":"Trabajos Pr√°cticos","content":"Objetivos    Que el alumno logre:\n Adquirir habilidades y conocimiento de las principales caracter√≠sticas y capacidades de las diferentes tecnolog√≠as y herramientas para el desarrollo y construcci√≥n de aplicaciones inform√°ticas actuales. Aplicar criterios de selecci√≥n de software en base a caracter√≠sticas y necesidades de un sistema. Adquirir habilidades en b√∫squeda y organizaci√≥n de informaci√≥n.   Modalidad de Desarrollo    Grupal: en grupos de entre 4 y 6 alumnos.\nFormato de Presentaci√≥n    Individual con coloquio en m√°quina e informe impreso y digital (formato .odt .doc .pdf).\nFecha de Entrega    25/06/2021  Exposici√≥n Grupal    25/06/2021  Contenido del Informe de Presentaci√≥n     Formato de hoja: A4. Car√°tula: Nombre de la materia, a√±o de cursado, n√∫mero de grupo, nombre completo de los integrantes. Correo electr√≥nico de cada integrante. √çndice de contenidos: √≠ndice tem√°tico de contenidos. Cuadro Comparativo: Cuadro sin√≥ptico resumen de doble entrada (caracter√≠stica x herramienta) conteniendo los principales √≠tems y cuantificaciones. Bibliograf√≠a: Citaci√≥n de Fuentes de referencia de la documentaci√≥n o bibliograf√≠a consultada.  Aspectos de Evaluaci√≥n     Cumplimiento de actividades propuestas y fechas indicadas. Investigaci√≥n y desarrollo del material. Presentaci√≥n.  La correcta redacci√≥n de los textos, su ortograf√≠a y puntuaci√≥n. La relaci√≥n y coherencia en cuanto a los tipos de letras utilizados para los cap√≠tulos, partes o secciones componentes del informe.    Actividad 1: Informe conceptos de Docker y ejemplo pr√°ctico      Conceptos te√≥ricos:\n Breve introducci√≥n a Docker. Ventajas y desventajas de utilizar Docker. Diferencias de Docker respecto de M√°quinas virtuales. Cuadro comparativo. Breve descripci√≥n de los siguientes conceptos: im√°gen, Dockerfile, container, vol√∫menes y links. Introducci√≥n a multistage builds con Docker.    Ejemplo pr√°ctico:\n Desarrollar un API Rest en Node.js que utilice una base de datos (relacional o no relacional) y desplegarlo en Docker. Para ello realizar las siguientes tareas:  Utilizar una imagen de Docker de la base de datos elegida. Construir la imagen de Docker de la API Rest utilizando multi-stage builds. Construir un docker-compose para instalar y desinstalar la aplicaci√≥n. En el archivo README.md del repositorio del trabajo pr√°ctico deben quedar reflejado los siguientes comandos: instalaci√≥n / construcci√≥n de la aplicaci√≥n, deploy / undeploy en Docker de la aplicaci√≥n. Crear una rama para subir el c√≥digo del grupo al repositorio.      Repositorio: https://github.com/FRRe-DACS/TP2-Docker-2021\n  "},{"id":3,"href":"/teoria-practicos/acceso-datos/orm/","title":"Object Relational Mapping","parent":"Capa de Acceso a Datos","content":"¬øQu√© es una ORM?    Una ORM procede de las siglas (Object Relational Mapping). Es un modelo de programaci√≥n que transforma las tablas de las bases de datos en entidades para simplificar enormemente la tarea del programador. El trabajo deja de ser manual ya que el ORM lo realizara de forma independiente de la base de datos. Adem√°s, gracias al mapeo autom√°tico podr√°s cambiar el motor de la base de datos f√°cilmente.\n¬øPor qu√© es mejor un ORM que otro lenguaje de programaci√≥n?    Un ORM tiene algunas ventajas y desventajas tambi√©n. Sus ventajas son la facilidad y velocidad de uso, la seguridad contra ataques inform√°ticos o la forma de abstracci√≥n de la base de datos que estemos utilizando. Por otro lado, para programar con ORM es necesario aprender su lenguaje y hay entornos con gran volumen que puede ver mermado su rendimiento. Uno de los mapeos autom√°ticos m√°s utilizado es de Java y se llama Hibernate, pero tambi√©n est√°n iBatis, Ebean, para .Net nHibernate , Entity Framework, entre otros.\nORM Sequelize    Es un ORM de Node.js basado en promesas para Postgres, MySql, MariaDB, SQLite, Microsoft SQL Server. Cuenta con un s√≥lido soporte de transacciones, relaciones, carga ansiosa, y perezosa, replicaci√≥n de lectura y mucho m√°s.\nComando para instalar el m√≥dulo de Sequelize\n$ npm install --save sequelize Modelo    Un modelo es una abstracci√≥n que representa una tabla en una base de datos. En Sequelize, es una clase que extiende de Model. El modelo le dice a Sequelize varias cosas sobre la entidad que representa, como el nombre de la tabla de la bases de datos y que columna tiene y sus tipos. Un modelo en Sequelize tiene un nombre. Este nombre no tiene que ser el mismo nombre de la tabla que representa en la base de datos. Por lo general, los modelos tienen nombres en singular (como User) mientras que las tablas tienen nombres en plural (como Users).\nDefinici√≥n de Modelos    Los modelos se pueden definir de dos maneras equivalentes en Sequelize:\n‚Ä¢\tSequelize define(modelName, attributes, options)\n‚Ä¢\tExtendiendo el modelo y llamando init(attributes, options) \nUtilizando sequealize.\nconst { Sequelize, DataTypes } = require(\u0026#39;sequelize\u0026#39;); const sequelize = new Sequelize(\u0026#39;sqlite::memory:\u0026#39;); const User = sequelize.define(\u0026#39;User\u0026#39;, { // Model attributes are defined here  firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING // allowNull defaults to true  } }, { // Other model options go here }); // `sequelize.define` also returns the model console.log(User === sequelize.models.User); // true Modelo Extensible    const { Sequelize, DataTypes, Model } = require(\u0026#39;sequelize\u0026#39;); const sequelize = new Sequelize(\u0026#39;sqlite::memory\u0026#39;); class User extends Model {} User.init({ // Model attributes are defined here  firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING // allowNull defaults to true  } }, { // Other model options go here  sequelize, // We need to pass the connection instance  modelName: \u0026#39;User\u0026#39; // We need to choose the model name }); // the defined model is the class itself console.log(User === sequelize.models.User); // true Sincronizaci√≥n de Modelos    Cuando define un modelo, le est√° diciendo a Sequelize algunas cosas sobre su tabla en la base de datos. Sin embargo, ¬øqu√© pasa si la tabla ni siquiera existe en la base de datos? ¬øQu√© pasa si existe, pero tiene diferentes columnas, menos columnas o cualquier otra diferencia? Aqu√≠ es donde entra en juego la sincronizaci√≥n del modelo. Un modelo se puede sincronizar con la base de datos llamando a model.sync(options)una funci√≥n asincr√≥nica (que devuelve una Promise). Con esta llamada, Sequelize realizar√° autom√°ticamente una consulta SQL a la base de datos. Tenga en cuenta que esto cambia solo la tabla en la base de datos, no el modelo en el lado de JavaScript.\n‚Ä¢\tUser.sync() - Esto crea la tabla si no existe (y no hace nada si ya existe)\n‚Ä¢\tUser.sync({ force: true }) - Esto crea la tabla, solt√°ndola primero si ya exist√≠a\n‚Ä¢\tUser.sync({ alter: true }) - Esto verifica cu√°l es el estado actual de la tabla en la base de datos (qu√© columnas tiene, cu√°les son sus tipos de datos, etc.), y luego realiza los cambios necesarios en la tabla para que coincida con el modelo.\nEjemplo\nawait User.sync({ force: true }); console.log(\u0026#34;The table for the User model was just (re)created!\u0026#34;); Sincronizar todos los modelos a la vez    Puede utilizar sequelize.sync() para sincronizar autom√°ticamente todos los modelos.\nEjemplo\nawait sequelize.sync({ force: true }); console.log(\u0026#34;All models were synchronized successfully.\u0026#34;); Instancia del Modelo    Una instancia de la clase representa un objeto de ese modelo (que se asigna a una fila de la tabla en la base de datos). De esta forma, las instancias de modelo son DAO.\nconst { Sequelize, Model, DataTypes } = require(\u0026#34;sequelize\u0026#34;); const sequelize = new Sequelize(\u0026#34;sqlite::memory:\u0026#34;); const User = sequelize.define(\u0026#34;user\u0026#34;, { name: DataTypes.TEXT, favoriteColor: { type: DataTypes.TEXT, defaultValue: \u0026#39;green\u0026#39; }, age: DataTypes.INTEGER, cash: DataTypes.INTEGER }); (async () =\u0026gt; { await sequelize.sync({ force: true }); // Code here })(); Consulta de Modelo    Consulta INSERT    Primero, un ejemplo simple:\n// Create a new user const jane = await User.create({ firstName: \u0026#34;Jane\u0026#34;, lastName: \u0026#34;Doe\u0026#34; }); console.log(\u0026#34;Jane\u0026#39;s auto-generated ID:\u0026#34;, jane.id); El Model.create() m√©todo es una forma abreviada de crear una instancia sin Model.build() guardar y guardar la instancia con instance.save().\nTambi√©n es posible definir qu√© atributos se pueden configurar en el createm√©todo. Esto puede ser especialmente √∫til si crea entradas de base de datos basadas en un formulario que puede ser llenado por un usuario. Usar eso, por ejemplo, le permitir√≠a restringir el Usermodelo para establecer solo un nombre de usuario y una direcci√≥n, pero no una marca de administrador:\nconst user = await User.create({ username: \u0026#39;alice123\u0026#39;, isAdmin: true }, { fields: [\u0026#39;username\u0026#39;] }); // let\u0026#39;s assume the default of isAdmin is false console.log(user.username); // \u0026#39;alice123\u0026#39; console.log(user.isAdmin); // false Consulta SELECT    Puede leer la tabla completa de la base de datos con el findAll m√©todo.\n// Find all users const users = await User.findAll(); console.log(users.every(user =\u0026gt; user instanceof User)); // true console.log(\u0026#34;All users:\u0026#34;, JSON.stringify(users, null, 2)); SELECT * FROM \u0026hellip;    Especificar atributos para consultas SELECT Para seleccionar solo algunos atributos, puede usar la attributesopci√≥n:\nModel.findAll({ attributes: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] }); SELECT foo, bar FROM \u0026hellip;    Se puede cambiar el nombre de los atributos mediante una matriz anidada:\nModel.findAll({ attributes: [\u0026#39;foo\u0026#39;, [\u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;], \u0026#39;qux\u0026#39;] }); SELECT foo, bar AS baz, qux FROM \u0026hellip;    Puede usar sequelize.fnpara hacer agregaciones:\nModel.findAll({ attributes: [ \u0026#39;foo\u0026#39;, [sequelize.fn(\u0026#39;COUNT\u0026#39;, sequelize.col(\u0026#39;hats\u0026#39;)), \u0026#39;n_hats\u0026#39;], \u0026#39;bar\u0026#39; ] }); SELECT foo, COUNT(hats) AS n_hats, bar FROM \u0026hellip;    Cuando utilice la funci√≥n de agregaci√≥n, debe darle un alias para poder acceder a ella desde el modelo. En el ejemplo anterior, puede obtener el n√∫mero de sombreros con instance.n_hats. A veces puede resultar tedioso enumerar todos los atributos del modelo si solo desea agregar una agregaci√≥n:\n// This is a tiresome way of getting the number of hats (along with every column) Model.findAll({ attributes: [ \u0026#39;id\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;qux\u0026#39;, \u0026#39;hats\u0026#39;, // We had to list all attributes...  [sequelize.fn(\u0026#39;COUNT\u0026#39;, sequelize.col(\u0026#39;hats\u0026#39;)), \u0026#39;n_hats\u0026#39;] // To add the aggregation...  ] }); // This is shorter, and less error prone because it still works if you add / remove attributes from your model later Model.findAll({ attributes: { include: [ [sequelize.fn(\u0026#39;COUNT\u0026#39;, sequelize.col(\u0026#39;hats\u0026#39;)), \u0026#39;n_hats\u0026#39;] ] } }); SELECT id, foo, bar, baz, qux, hats, COUNT(hats) AS n_hats FROM \u0026hellip;    Consulta de Actualizaci√≥n    Las consultas de actualizaci√≥n tambi√©n aceptan la where opci√≥n, al igual que las consultas de lectura que se muestran arriba.\n// Change everyone without a last name to \u0026#34;Doe\u0026#34; await User.update({ lastName: \u0026#34;Doe\u0026#34; }, { where: { lastName: null } }); Consulta de Eliminaci√≥n    Las consultas de eliminaci√≥n tambi√©n aceptan la where opci√≥n, al igual que las consultas de lectura que se muestran arriba.\n// Delete everyone named \u0026#34;Jane\u0026#34; await User.destroy({ where: { firstName: \u0026#34;Jane\u0026#34; } }); Para destruir todo lo que TRUNCATEse puede usar el SQL:\n// Truncate the table await User.destroy({ truncate: true }); Validaciones y Restricciones    const { Sequelize, Op, Model, DataTypes } = require(\u0026#34;sequelize\u0026#34;); const sequelize = new Sequelize(\u0026#34;sqlite::memory:\u0026#34;); const User = sequelize.define(\u0026#34;user\u0026#34;, { username: { type: DataTypes.TEXT, allowNull: false, unique: true }, hashedPassword: { type: DataTypes.STRING(64), is: /^[0-9a-f]{64}$/i } }); (async () =\u0026gt; { await sequelize.sync({ force: true }); // Code here })(); Diferencia entre validaciones y restricciones    Las validaciones son comprobaciones realizadas en el nivel Sequelize, en JavaScript puro. Pueden ser arbitrariamente complejos si proporciona una funci√≥n de validaci√≥n personalizada, o pueden ser uno de los validadores integrados que ofrece Sequelize. Si falla una validaci√≥n, no se enviar√° ninguna consulta SQL a la base de datos. Por otro lado, las restricciones son reglas definidas a nivel de SQL. El ejemplo m√°s b√°sico de restricci√≥n es una restricci√≥n √∫nica. Si falla una verificaci√≥n de restricci√≥n, la base de datos arrojar√° un error y Sequelize enviar√° este error a JavaScript (en este ejemplo, arrojar√° un SequelizeUniqueConstraintError). Tenga en cuenta que en este caso se realiz√≥ la consulta SQL, a diferencia del caso de las validaciones.\nPermitir y Rechazar valores nulos De forma predeterminada, nulles un valor permitido para cada columna de un modelo. Esto se puede deshabilitar configurando la allowNull: false opci√≥n para una columna.\n/* ... */ { username: { type: DataTypes.TEXT, allowNull: false, unique: true }, } /* ... */ Biblioteca de Conectores    MySQL    La biblioteca de conectores subyacente utilizada por Sequelize para MySQL es el paquete mysql2 npm (versi√≥n 1.5.2 o superior).\nPuede proporcionarle opciones personalizadas usando dialectOptionsen el constructor Sequelize:\nconst sequelize = new Sequelize(\u0026#39;database\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, { dialect: \u0026#39;mysql\u0026#39;, dialectOptions: { // Your mysql2 options here  } }) MariaDB    La biblioteca de conectores subyacente utilizada por Sequelize para MariaDB es el paquete mariadb npm.\nPuede proporcionarle opciones personalizadas usando dialectOptionsen el constructor Sequelize:\nconst sequelize = new Sequelize(\u0026#39;database\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, { dialect: \u0026#39;mariadb\u0026#39;, dialectOptions: { // Your mariadb options here  // connectTimeout: 1000  } }); SQLite    La biblioteca de conectores subyacente utilizada por Sequelize para SQLite es el paquete sqlite3 npm (versi√≥n 4.0.0 o superior).\nEl archivo de almacenamiento se especifica en el constructor Sequelize con la storageopci√≥n (utilizar :memory:para una instancia de SQLite en memoria). Puede proporcionarle opciones personalizadas usando dialectOptionsen el constructor Sequelize:\nconst sequelize = new Sequelize(\u0026#39;database\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, { dialect: \u0026#39;sqlite\u0026#39;, storage: \u0026#39;path/to/database.sqlite\u0026#39; // or \u0026#39;:memory:\u0026#39;  dialectOptions: { // Your sqlite3 options here  } }); PostgreSQL    La biblioteca de conectores subyacente utilizada por Sequelize para PostgreSQL es el paquete pg npm (versi√≥n 7.0.0 o superior). El m√≥dulo pg-hstore tambi√©n es necesario.\nPuede proporcionarle opciones personalizadas usando dialectOptionsen el constructor Sequelize:\nconst sequelize = new Sequelize(\u0026#39;database\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, { dialect: \u0026#39;postgres\u0026#39;, dialectOptions: { // Your pg options here  } }); Para conectarse a trav√©s de un socket de dominio Unix, especifique la ruta al directorio del socket en la hostopci√≥n. La ruta del socket debe comenzar con /.\nconst sequelize = new Sequelize(\u0026#39;database\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, { dialect: \u0026#39;postgres\u0026#39;, host: \u0026#39;/path/to/socket_directory\u0026#39; }); MSSQL    La biblioteca de conectores subyacente utilizada por Sequelize para MSSQL es el tedioso paquete npm (versi√≥n 6.0.0 o superior).\nPuede proporcionarle opciones personalizadas usando dialectOptions.optionsen el constructor Sequelize:\nconst sequelize = new Sequelize(\u0026#39;database\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, { dialect: \u0026#39;postgres\u0026#39;, dialectOptions: { // Observe the need for this nested `options` field for MSSQL  options: { // Your tedious options here  useUTC: false, dateFirst: 1 } } }); Migraciones    Al igual que usa sistemas de control de versiones como Git para administrar los cambios en su c√≥digo fuente, puede usar las migraciones para realizar un seguimiento de los cambios en la base de datos. Con las migraciones, puede transferir su base de datos existente a otro estado y viceversa: esas transiciones de estado se guardan en archivos de migraci√≥n, que describen c√≥mo llegar al nuevo estado y c√≥mo revertir los cambios para volver al estado anterior.\nNecesitar√° Sequelize Command-Line Interface (CLI). La CLI incluye soporte para migraciones y arranque de proyectos.\nUna migraci√≥n en Sequelize es un archivo javascript que exporta dos funciones, up y down que dictan c√≥mo realizar la migraci√≥n y deshacerla. Define esas funciones manualmente, pero no las llama manualmente; la CLI los llamar√° autom√°ticamente. En estas funciones, simplemente debe realizar las consultas que necesite, con la ayuda de sequelize.querycualquier otro m√©todo que Sequelize le proporcione. No hay magia adicional m√°s all√° de eso.\nInstalaci√≥n del CLI    Para instalar la CLI de Sequelize:\nnpm install --save-dev sequelize-cli "},{"id":4,"href":"/teoria-practicos/versionado/","title":"Sistemas de Control de Versiones","parent":"Teor√≠a Trabajos Pr√°cticos","content":"¬øQu√© es un Sistema de control de versiones?    Un Sistema de Versionado de C√≥digo (SVC) en abstracto es lo que nos permite¬†compartir el c√≥digo¬†fuente de nuestros desarrollos y a la vez¬†mantener un registro de los cambios¬†por los que va pasando.\nHabitualmente para gestionar las distintas versiones por las que pasa el c√≥digo fuente de las aplicaciones, lo que nos permite saber qui√©n realiza qu√© cambios y poder volver a ellos en un determinado momento. Los m√°s utilizados en este campo a lo largo del tiempo (aunque existen bastante m√°s) son CVS, Subversion y Git\nVer presentaci√≥n: Sistemas de control de versiones\n¬øPorqu√© usar un control de versiones nos har√° felices?    ‚óè Proporciona copias de seguridad autom√°ticas de los ficheros.\n‚óè Permite volver a un estado anterior de nuestros ficheros.\n‚óè Ayuda a trabajar de una forma m√°s organizada.\n‚óè Permite trabajar de forma local, sin conexi√≥n con servidor. (en distribu√≠dos).\n‚óè Permite que varias personas trabajen en los mismos ficheros.\n‚óè Permiten trabajar en varias funcionalidades en paralelo separado (ramas).\nEl antes y el despu√©s de conocer los sistemas de control de versiones    En alg√∫n momento de nuestras vidas nuestra carpeta de documentos luciera como la de la imagen y nos haya tocado recurrir a tener muchas copias de nuestros proyectos.\nTiempo despu√©s por alg√∫n accidente del destino conocemos los sistemas de control de versiones y no podemos negarlo, nuestras vidas cambian y entramos a una era donde todo es mucho m√°s bonito: el despu√©s. El control de versiones es un sistema que registra los cambios realizados sobre un archivo o conjunto de archivos a lo largo del tiempo de tal manera que sea posible recuperar versiones especificas m√°s adelante\nTipos de Sistemas de Control de Versiones    Sistemas de Control de Versiones Locales    En vez de mantener las versiones como archivos independientes, los almacenaban en una base de datos.\nEN cualquier momento solo se tenia una copia del proyecto, eliminando la posibilidad de confundir o eliminar versiones. En este punto el control de versiones se llevaba a cabo en el computador de cada uno de los desarrolladores y no exist√≠a una manera eficiente de compartir el c√≥digo entre ellos\nSistemas de Control de Versiones Centralizados    Para facilitar la colaboraci√≥n de m√∫ltiples desarrolladores en un solo proyecto los sistemas de control de versiones evolucionaron: en vez de almacenar los cambios y versiones en el disco duro de los desarrolladores, estos se almacenaban en un servidor. los sistemas centralizados trajeron consigo nuevos retos: ¬øC√≥mo trabajaban m√∫ltiples usuarios en un mismo archivo al mismo tiempo? Los sistemas de control de versiones centralizados abordaron este problema impidiendo que los usuarios invalidaran el trabajo de los dem√°s. Si dos personas editaban el mismo archivo y se presentaba un conflicto alguien deb√≠a solucionar este problema de manera manual y el desarrollo no pod√≠a continuar hasta que todos los conflictos fueran resueltos y puestos a disposici√≥n del resto del equipo.\nEsta soluci√≥n funcion√≥ en proyectos que ten√≠an relativamente pocas actualizaciones y por ende pocos conflictos pero resulto muy engorroso para proyectos con docenas de contribuyentes activos que realizaban actualizaciones a diario.\nSistemas de Control de Versiones Distribuidos    Este SCV opt√≥ por darle a cada desarrollador una copia local de todo el proyecto, de esta manera se construyo una red distribuida de repositorios, en la que cada desarrollador pod√≠a trabajar de manera aislada pero teniendo un mecanismo de resoluci√≥n de conflictos mucho m√°s elegante que un su versi√≥n anterior. Al no existir un repositorio central, cada desarrollador puede trabajar a su propio ritmo, almacenar los cambios a nivel local y mezclar los conflictos que se presenten solo cuando se requiera. C√≥mo cada usuario tiene una copia completa del proyecto el riesgo por una ca√≠da del servidor, un repositorio da√±ado o cualquier otro tipo de perdida de datos es mucho menor que en cualquiera de sus predecesores\nEjemplos de SCV    CVS    CVS (Concurrent Versions System) es uno de los primeros sistemas de control de versiones. Tiene una arquitectura cliente-¬≠servidor, en la que el c√≥digo est√° almacenado en un servidor central y con el software cliente podemos hacer una copia del c√≥digo local para hacer cambios y posteriormente volver a subirla al servidor. Permite el trabajo concurrente entre distintos programadores, pero el servidor solo acepta actualizaciones de los ficheros que est√©n en la √∫ltima versi√≥n, de forma que los propios usuarios deben actualizar sus copias locales antes de subirlas al servidor. Soporta adem√°s el trabajo en distintas ramas. Se hizo bastante popular entre la comunidad de software libre por ser lanzado bajo la licencia GNU.\nSVN    El proyecto de Subversion surgi√≥ en el a√±o 2000 con el objetivo crear un sistema de\u000bcontrol de versiones con la misma filosof√≠a que CVS, pero arreglando problemas y cubriendo carencias del mismo:\n‚óè Commits at√≥micos, en CVS un commit interrumpido puede dejar datos inconsistentes.\n‚óè La creaci√≥n de ramas es m√°s eficiente, con complejidad constante a diferencia de CVS que es lineal (aumenta con el n√∫mero de ramas).\n‚óè Manejo de archivos binarios como tal, CVS los trata como archivos de texto.\n‚óè Env√≠a los incrementos de los ficheros en la comunicaci√≥n cliente¬≠servidor, en lugar de los ficheros completos como CVS.\nLa estructura m√°s habitual en un repositorio SVN:\n‚óè Trunk con la versi√≥n del c√≥digo principal.\n‚óè Tags para almacenar las distintas versiones de una aplicaci√≥n que no volver√°n a modificarse.\n‚óè Branches para gestionar las distintas versiones de c√≥digo que se desarrollan paralelas al trunk Al ser tambi√©n software libre, ha sido adoptado por multitud de proyectos, incluso en grandes corporaciones, convirti√©ndose en un referente.\nGIT    En 2005, Linus Torvalds inici√≥ el desarrollo de Git como alternativa a BitKeeper (que hab√≠a pasado a ser SW propietario), el sistema de control de versiones que se us√≥ hasta el momento para desarrollar el kernel de Linux. Por esto, Git nace con las principales necesidades de ser r√°pido, eficiente y distribuido:\n‚óè R√°pido: combinando el trabajo sobre el repositorio local y la posterior distribuci√≥n remota.\n‚óè Eficiente: pensado para manejar grandes proyectos con muchos ficheros (Linux) y no se vuelve lento a medida que la historia del proyecto crece.\n‚óè Distribuido: fundamental para el trabajo concurrente y en remoto de muchos usuarios. Cada usuario tiene una copia local en la que trabajar, que posteriormente sincroniza con el resto de usuarios. Es tambi√©n especialmente efectivo a la hora de mezclar los cambios hechos por distintos usuarios.\nCaracter√≠sticas    Su sencillez es lo que lo diferencia de otros sistemas de control de versiones y lo que le hace verdaderamente potente.\nLa mayor√≠a de sistemas del momento almacenaban los cambios (deltas) en los ficheros entre distintas versiones y requer√≠an de complejos algoritmos de aplicaci√≥n de esos deltas para recuperar un determinado estado del repositorio. Git en cambio es una sencilla base de datos clave¬≠-valor, en la que cada versi√≥n apunta a un √°rbol de nodos que representa la estructura de directorios y contenidos comprimidos de los ficheros. Esto le permite recuperar estados √∫nicamente apuntando a un determinado √°rbol y facilita las tareas de distribuci√≥n y mezclado de contenidos\nDistribuido: cada usuario dispone de un repositorio completo de forma local. Esto permite trabajar sin necesidad de conexi√≥n a un servidor para realizar las distintas acciones, pudiendo m√°s tarde sincronizar nuestros datos con el servidor.\nOtra de las particularidades de Git es el √°rea de stage. La gran mayor√≠a de sistemas almacenan la informaci√≥n en dos sitios, la copia lo al de ficheros y directorios del usuario, y el almacenamiento de versiones.\nGit proporciona una tercera opci√≥n con el √°rea de stage. Consiste en un √°rea intermedia entre las otras dos, donde ir colocando los cambios de la copia local con las que queremos hacer un nuevo commit. De esta forma se consigue mucha m√°s versatilidad y control a la hora de ir guardando versiones del c√≥digo.\n"},{"id":5,"href":"/trabajos-practicos/tp-final/","title":"Trabajo Pr√°ctico Final","parent":"Trabajos Pr√°cticos","content":"Objetivos    Que el alumno logre:\n Adquirir habilidades pr√°cticas sobre los conocimientos impartidos en las principales tecnolog√≠as y herramientas para el desarrollo y construcci√≥n de aplicaciones inform√°ticas actuales.   Modalidad de Desarrollo    Grupal: en grupos de entre 4 y 6 alumnos.\nFormato de Presentaci√≥n    Individual con coloquio en m√°quina e informe impreso y digital (formato .odt .doc .pdf).\nFecha de Entrega    02/07/2021  Contenido del Informe de Presentaci√≥n     Formato de hoja: A4. Car√°tula: Nombre de la materia, a√±o de cursado, n√∫mero de grupo, nombre completo de los integrantes. Correo electr√≥nico de cada integrante. √≠ndice de contenidos: √≠ndice tem√°tico de contenidos, organizado por lenguaje o herramientas de programaci√≥n. Informe detallado: Descripci√≥n de las decisiones de dise√±o y de las soluciones implementadas para cumplimentar el pr√°ctico.  Aspectos de Evaluaci√≥n    La evoluci√≥n de trabajo se realizar√° de acuerdo a la siguiente tabla:\n   Aspecto Item Condici√≥n Puntaje     Cumplimiento funcional de la aplicaci√≥n Funcionalidad Mandatorio 15   Arquitectura empleada       Multiplataforma Opcional 10    Cliente Liviano y cliente m√≥vil Mandatorio 10   Acceso a Datos       Base de Datos Mandatorio 10    ORM Opcional 10   L√≥gica de Negocios  Mandatorio     Validaci√≥n de Datos Opcional 5    Exposici√≥n de Servicios (Web Services) Mandatorio 15   Presentaci√≥n       Usabilidad Mandatorio 10    MVC Opcional 10    Estilos Opcional 5   Total   100    Actividad 1: Escenario    El Ministerio de Desarrollo Productivo, junto con la Secretar√≠a de Comercio Interior han sancionado la Resoluci√≥n 237/2021 por la cual se crea el Sistema Informativo para la Implementaci√≥n de Pol√≠ticas de Reactivaci√≥n Econ√≥mica (SIPRE).\nEste sistema, cuyo objetivo final es contribuir a la reactivaci√≥n econ√≥mica del pa√≠s, tiene por alcance a todas las empresas del sector comercio e industria local. Estas empresas deber√° suministrar informaci√≥n de forma mensual, a trav√©s del repositorio de informaci√≥n del MINISTERIO DE DESARROLLO PRODUCTIVO, los primeros diez (10) d√≠as corridos de cada mes calendario.\nLa informaci√≥n suministrada deber√° contener, como m√≠nimo, los siguientes datos:\n CUIT de la empresa. Denominaci√≥n del producto. C√≥digo EAN o equivalente sectorial del producto; y Precio por unidad de peso, cantidad o medida del producto. Cantidades producidas y vendidas  Para esto los alumnos de la c√°tedra Desarrollo de Aplicaciones Cliente-Servidor deber√° desarrollar un sistema que implemente los siguiente sub-sistemas:\nMinisterio de Desarrollo Productivo    Este sub-sistema deber√° exponer las APIs (Application Programing Interface) para que las empresas presenten mensualmente la informaci√≥n de regimen informativo de la resoluci√≥n. A su vez, deber√° exponer servicios para resumir la informaci√≥n que est√° disponible para la Secretar√≠a de Comercio Interior.\nEmpresas del Sector Comercio    Se deber√° crear librerias para acceder y publicar los reg√≠menes informativos al Ministerio de Desarrollo Productivo. Se deber√° proveer una implementaci√≥n de referencia, que utilice la librer√≠a y publique los datos en el Ministerio.\nSecretar√≠a de Comercio Interior    La Secreter√≠a de Comercio Interior debe ser capaz de consultar los datos publicados en el repositorio de informaci√≥n del Ministerio de Desarrollo Productivo, y por medio de ciertas reglas de negocios y pol√≠ticas establacidas, generar altertas de incumplimiento, y en caso de ser necesario, reportar al comercio el incumplimiento de la normativa.\nDesarrollo    Para el desarrollo del TP, los grupos deber√°n definir, coordinando entre ellos, las APIs de los diferentes actores y publicarlas en el sitio web de la materia (por medio de PRs).\nPor ejemplo: para la definici√≥n de las APIs, los diferentes grupos deber√°n generar, en forma colaborativa el documento de Definici√≥n de APIs. Esto lo deber√°n hacer, haciendo un fork de repositorio del sitio web, generando la documentaci√≥n y realizando un PR, como se dio en el TP 1.\n"},{"id":6,"href":"/programa-analitico/unidad-01/","title":"UNIDAD 1","parent":"Programa Anal√≠tico","content":"Introducci√≥n a las aplicaciones cliente-servidor    Repaso de las arquitecturas m√°s comunes en sistemas distribuidos. Modelo de capas. Dos y tres capas. Modelo de tres capas, la tendencia actual. Modelo distribuido y de microservices, introducci√≥n. Interfaces de acceso a los datos: ODBC, OLE DB y los objetos ADO. JDBC. Publicadores y consumidores de datos. Patrones de dise√±o en arquitecturas distribuidas, Event-Sourcing.\nObjetivos espec√≠ficos     Discriminar las diferencias conceptuales entre las distintas tecnolog√≠as existentes.  "},{"id":7,"href":"/teoria-practicos/acceso-datos/","title":"Capa de Acceso a Datos","parent":"Teor√≠a Trabajos Pr√°cticos","content":"Node.js    NodeJs es un entorno de tiempo de ejecuci√≥n de JavaScript (de ah√≠ su terminaci√≥n en .js).\nNodeJs fue creado por los desarrolladores originales de JavaScript. Lo transformaron en algo que solo se pod√≠a ejecutarse en el navegador en algo que se podr√≠a ejecutar en los ordenadores como si de aplicaciones independiente se tratara . Tanto JavaScript como NodeJs se ejecutan en el motor de tiempo de ejecuci√≥n JavaScript V8 (V8 es el nombre del motor de JavaScript que alimenta Google Chrome).\n¬øPara que sirve Node.Js?    Node.js utiliza un modelo de entrada y salida sin bloqueo controlado por eventos que lo hace ligero y eficiente (con entrada nos referimos a solicitudes y con salidas a respuestas). Puede referirse cualquier operaci√≥n desde leer o escribir archivos de cualquier tipo hasta hacer una solicitud HTTP. La idea principal de Node.Js es usar un modelo de entrada y salida sin bloqueo y controlado por eventos para seguir siendo liviano y eficiente frente a las aplicaciones en tiempo real de uso de datos que se ejecutan en los dispositivos. La finalidad de Node.Js no tiene su objetivo en operaciones intensivas en el uso del procesador, de hecho de usarlo para programaci√≥n de m√°s peso eliminara casi todas sus ventajas. Donde Node.Js realmente brilla es en la creaci√≥n de aplicaciones de red r√°pidas, ya que es capaz de manejar gran cantidad de conexiones simult√°neas con un alto nivel de rendimiento, lo que equivale a una alta escalabilidad.\nVentaja    ‚Ä¢\tTiene incorporado JavaScript en la plataforma de Node.Js, siendo un lenguaje f√°cil de aprender.\n‚Ä¢\tSe desarrolla en un entorno de tiempo de ejecuci√≥n de fuentes libres que ayudara en el almacenamiento de creaci√≥n de proyectos √∫nicos.\n‚Ä¢\tEl modelo de entrada y salida impulsado por eventos ayuda mucho en el manejo simultaneo de peticiones.\nFrameworks de Acceso a Datos    Respecto de Acceso a Datos hablaremos de los siguientes frameworks:\n‚Ä¢ ORM - Object Relational Mapping\n‚Ä¢ ODM - Object Document Mapper\n"},{"id":8,"href":"/teoria-practicos/acceso-datos/odm/","title":"Object Document Mapper","parent":"Capa de Acceso a Datos","content":"Introducci√≥n    Cuando queremos guardar en una DB info solemos usar su lenguaje propio dentro de nuestro c√≥digo. Pero a veces tenemos que hacer todo un esfuerzo para que este lenguaje de consulta funcione dentro de nuestro c√≥digo. Esto se puede evitar con un orm, o un ODM en el caso de una base de datos no relacional como MongoDB. El ODM hace de intermediario entre la app y la DB as√≠ tenemos m√©todos propios que hacen todo el trabajo.\nMongoose    MongooseJS es un Object Document Mapper (ODM) que facilita el uso de MongoDB al traducir documentos en una base de datos MongoDB a objetos en el programa. Adem√°s de MongooseJS, hay varios otros ODM que se han desarrollado para MongoDB, incluidos Doctrine, MongoLink y Mandango. Las cuatro ventajas principales de usar Mongoose frente a MongoDB nativo son:\n‚óè MongooseJS proporciona una capa de abstracci√≥n sobre MongoDB que elimina la necesidad de utilizar colecciones con nombre.\n‚óè Los modelos en Mongoose realizan la mayor parte del trabajo de establecer valores predeterminados para las propiedades del documento y validar los datos.\n‚óè Las funciones se pueden adjuntar a los modelos en MongooseJS. Esto permite la incorporaci√≥n perfecta de nuevas funciones.\n‚óè Las consultas utilizan el encadenamiento de funciones en lugar de los mnem√≥nicos incrustados que dan como resultado un c√≥digo que es m√°s flexible y legible, y por lo tanto m√°s f√°cil de mantener.\nEl resultado neto de estos es la simplificaci√≥n del acceso a la base de datos desde las aplicaciones. La principal desventaja de Mongoose es que la abstracci√≥n tiene un costo de rendimiento en comparaci√≥n con el de MongoDB nativo.\n¬øPor qu√© Mongoose si ya existe el cliente de mongoDB?    Mongoose usa esquemas para modelar los datos que una aplicaci√≥n desea almacenar y manipular en MongoDb. Esto incluye funciones como conversi√≥n de tipos, validaci√≥n, creaci√≥n de consultas y m√°s. El esquema describe los atributos de las propiedades (tambi√©n conocidos como campos) que la aplicaci√≥n manipulara. Estos atributos incluyen cosas como:\n‚óè Tipo de datos, en total son 8: String, Number, Date, Buffer (archivos onda PDF), Boolean, Mixed (puede venir cualquier cosa), ObjectId (links a otros documentos en la DB), Array.\n‚óè Si es obligatorio u opcional.\n‚óè Su valor por defecto.\n‚óè Crear √≠ndices para que la informaci√≥n sea obtenida m√°s r√°pido.\nGetters/Setters en Mongoose    Una funci√≥n GET que te permite manipular la informaci√≥n entrante antes de ser devuelta como objeto:\nconst userSchema = new Schema({ email: { type: String, get: obfuscate } }); // Mongoose passes the raw value in MongoDB `email` to the getter function obfuscate(email) { const separatorIndex = email.indexOf(\u0026#39;@\u0026#39;); if (separatorIndex \u0026lt; 3) { // \u0026#39;ab@gmail.com\u0026#39; -\u0026gt; \u0026#39;**@gmail.com\u0026#39;  return email.slice(0, separatorIndex).replace(/./g, \u0026#39;*\u0026#39;) + email.slice(separatorIndex); } // \u0026#39;test42@gmail.com\u0026#39; -\u0026gt; \u0026#39;te****@gmail.com\u0026#39;  return email.slice(0, 2) + email.slice(2, separatorIndex).replace(/./g, \u0026#39;*\u0026#39;) + email.slice(separatorIndex); } const User = mongoose.model(\u0026#39;User\u0026#39;, userSchema); const user = new User({ email: \u0026#39;ab@gmail.com\u0026#39; }); user.email; // **@gmail.com Una funci√≥n SET que permite manipular los datos antes de ser guardados en la base de datos\nconst userSchema = new Schema({ email: { type: String, set: v =\u0026gt; v.toLowerCase() } }); const User = mongoose.model(\u0026#39;User\u0026#39;, userSchema); const user = new User({ email: \u0026#39;TEST@gmail.com\u0026#39; }); user.email; // \u0026#39;test@gmail.com\u0026#39;  // The raw value of `email` is lowercased user.get(\u0026#39;email\u0026#39;, null, { getters: false }); // \u0026#39;test@gmail.com\u0026#39;  user.set({ email: \u0026#39;NEW@gmail.com\u0026#39; }); user.email; // \u0026#39;new@gmail.com\u0026#39; Con mongoose todo deriva de un esquema, por ello se genera un modelo a partir del esquema y define un documento en el que operar√° la aplicaci√≥n. M√°s precisamente, un modelo es una clase que define un documento con las propiedades y comportamientos declarados en nuestro esquema. Todas las operaciones de base de datos realizadas en un documento con Mongoose deben hacer referencia a un modelo.\nEl Esquema    El schema es la estructura que van a tener nuestros datos. Nos permite decidir exactamente qu√© datos queremos y qu√© opciones que los datos tengan como objeto.\nconst mongoose = require(\u0026#34;mongoose\u0026#34;); const FoodSchema = new mongoose.Schema({ nombre: { type: String, required: true, trim: true, lowercase: true, }, calorias: { type: Number, default: 0, validate(value) { if (value \u0026lt; 0) throw new Error(\u0026#34;Las calorias negativas no son reales.\u0026#34;); }, }, }); const Food = mongoose.model(\u0026#34;Food\u0026#34;, FoodSchema); module.exports = Food; Consiste en un nombre, de tipo String, ser√° obligatorio, se limpian espacios en blanco y estar√° en min√∫sculas. Tambi√©n tendremos calor√≠as, de tipo num√©rico, un valor por defecto de 0 y una validaci√≥n para que no pueda ser menor a 0.\nCRUD con Mongoose    Cuando quieres hacer un nuevo registro creas una nueva instancia de tu modelo e invocas al m√©todo save. En este caso estoy definiendo las propiedades manualmente, pero pueden venir de cualquier lugar.\nconst videojuego = new Videojuego({ nombre: \u0026#34;Cuphead\u0026#34;, precio: 180, calificacion: 10, }); await videojuego.save(); console.log(\u0026#34;Guardado\u0026#34;); Cuando quieres obtener todos los registros, invoca al m√©todo find:\nconst videojuegos = await Videojuego.find(); console.log(videojuegos); Si quieres obtener un registro por id, invoca a findById:\nconst id = \u0026#34;12354564asdf\u0026#34;; const videojuego = await Videojuego.findById(id); console.log(videojuego); En el caso de actualizar un registro por id puedes usar a findOneAndUpdate:\nconst id = \u0026#34;1235213asdf\u0026#34;; await Videojuego.findOneAndUpdate({ _id: id, }, { nombre: \u0026#34;Nuevo nombre\u0026#34;, precio: 500, calificacion: 9, }); console.log(\u0026#34;Actualizado\u0026#34;); Y finalmente para eliminar un registro a partir del ID puedes usar findOneAndDelete:\nconst id = \u0026#34;123213asdf\u0026#34;; await Videojuego.findOneAndDelete({ _id: id }); console.log(\u0026#34;Eliminado\u0026#34;); Conclusi√≥n    MongoDB nos proporciona las ventajas de una base de datos NoSQL, como la flexibilidad de la estructura de datos, la escalabilidad y el rendimiento sin abandonar conceptos que han hecho a las bases de datos relacionales lo que son hoy en d√≠a, como consistencia de datos y la integraci√≥n con otras herramientas de desarrollo. Sumado al poder administrarla en la nube con Mongo Atlas (soluci√≥n provista por los creadores del producto).\nPor estas caracter√≠sticas, MongoDB es una herramienta que cae como anillo al dedo para el desarrollo de aplicaciones como redes sociales, aplicaciones m√≥viles, CMS, entre otras, que debido a lo antes mencionado, requieren de una base de datos que ofrezca alto rendimiento y flexibilidad, a la vez que mantiene consistencia y seguridad en los datos.\nConsideramos que MongoDB es una herramienta f√°cil de aprender, √∫til y sumamente divertida. Principalmente al estar trabajando en proyectos personales o por hobby, no tenemos que pasar por todo el proceso de definici√≥n y esquema de tablas y relaciones. Sencillamente con que est√© corriendo MongoDB ya le podemos enviar informaci√≥n desde nuestras aplicaciones.\nEs id√≥neo adem√°s de que como en nuestro caso lo usamos en conjunto con Node y React, tampoco es necesario aprender varios lenguajes para realizar una aplicaci√≥n completa. Decidimos utilizar Node debido a su popularidad en la industria, tambi√©n el hecho de que nos pareci√≥ copado trabajar con el Stack MERN - Mongo Express React y Node. NodeJS nunca fue hecho para resolver el problema de escalado de computaci√≥n. Node fue creado para resolver el problema de escalado de E/S, lo que funciona de maravilla. Entonces cu√°ndo usarlo? La respuesta es simple, si el problema no contiene operaciones intensivas de CPU ni el acceso a los recursos de bloqueo, node es la respuesta.\n"},{"id":9,"href":"/programa-analitico/unidad-02/","title":"UNIDAD 2","parent":"Programa Anal√≠tico","content":"Servicios de BackEnd y servidores de aplicaciones    Arquitecturas de sistemas cliente servidor de 2 y 3 capas. Como se implementa una capa de negocios. Objetos basados en clases reutilizables. Modelos de ejecuci√≥n actuales. M√°quinas virtuales, containers y virtualizaci√≥n a nivel SO. Compiladores just-in-time. Distribuci√≥n de aplicaciones a trav√©s de la red. Frameworks de persistencia, hibernate, JPA.\nObjetivos espec√≠ficos     Seleccionar y aplicar correctamente las tecnolog√≠as existentes en el mercado. Que sepa analizar el contexto del problema y resuelva el mismo con la mejor herramienta posible.  "},{"id":10,"href":"/teoria-practicos/patrones/","title":"Patrones de Acceso a Datos","parent":"Teor√≠a Trabajos Pr√°cticos","content":"Patr√≥n Repositorio    El patr√≥n repositorio consiste en separar la l√≥gica que recupera los datos y los asigna a un modelo de entidad de la l√≥gica de negocios que act√∫a sobre el modelo, esto permite que la l√≥gica de negocios sea independiente del tipo de dato que comprende la capa de origen de datos, en pocas palabras un repositorio media entre el dominio y las capas de mapeo de datos, actuando como una colecci√≥n de objetos de dominio en memoria\nVer presentaci√≥n: Acceso Datos\nData Mappers    Es una capa de software que separa los objetos en memoria de la base de datos. Su responsabilidad es transferir datos entre los dos y tambi√©n aislarlos entre s√≠. Con Data Mapper, los objetos en memoria no necesitan saber ni siquiera que hay una base de datos presente; no necesitan c√≥digo de interfaz SQL y, ciertamente, ning√∫n conocimiento del esquema de la base de datos.\nDAO    El patr√≥n DAO propone separar por completo la l√≥gica de negocio de la l√≥gica para acceder a los datos, de esta forma, el DAO proporcionar√° los m√©todos necesarios para insertar, actualizar, borrar y consultar la informaci√≥n; por otra parte, la capa de negocio solo se preocupa por l√≥gica de negocio y utiliza el DAO para interactuar con la fuente de datos.\nCapa de Acceso a Datos:    Capa externa que va a contener todas las fuentes de datos desde donde vamos a extraer dichos datos para leerlos desde nuestra capa de dominio.\nQuery Object    Un objeto de consulta es un int√©rprete, es decir, una estructura de objetos que puede formarse en una consulta SQL. El patr√≥n de objeto de consulta en realidad utiliza el patr√≥n de asignaci√≥n de metadatos para generar consultas de base de datos reales.\nCapa de Dominio:    Es una capa que contiene todas las clases que forman parte de nuestra l√≥gica del negocio que vamos a implementar.\nCapa de Servicio:    Es una capa que contendr√° todos los m√©todos desde los cuales se realizar√°n las peticiones hacia la fuente de datos respectiva.\nVentajas y Desventajas       Ventajas Desventajas     Reutilizaci√≥n del c√≥digo de acceso a datos Implementaci√≥n compleja   L√≥gica del dominio sencilla de probar Requiere un nivel adicional de direccionamiento indirecto   Nos ayuda en el desacople de la l√≥gica Alto grado de dependencia en la interfaz de fachada   Permite implementar varias fuentes de persistencia de datos    Permite inyecci√≥n de dependencia     Aplicaci√≥n de capas    API    La interfaz de programaci√≥n de aplicaciones, conocida tambi√©n por la sigla API,application programming interface, es un conjunto de subrutinas, funciones y procedimientos (o m√©todos, en la programaci√≥n orientada a objetos) que ofrece cierta biblioteca para ser utilizado por otro software como una capa de abstracci√≥n. Es una especificaci√≥n formal sobre c√≥mo un m√≥dulo de un software se comunica o interact√∫a con otro, simplifican en gran medida el trabajo de un creador de programas, ya que no tiene que ¬´escribir¬ª c√≥digos desde cero.\n Son un medio simplificado para conectar su propia infraestructura a trav√©s del desarrollo de aplicaciones nativas de la nube, pero tambi√©n le permiten compartir sus datos con clientes y otros usuarios externos. No son la parte visible, sino los circuitos internos que s√≥lo los desarrolladores ven y conectan para hacer funcionar una herramienta.  Por ejemplo, cuando el usuario compra entradas a trav√©s de la p√°gina web de una sala de cine e introduce la informaci√≥n de su tarjeta de cr√©dito, la web usa una API para enviar dicha informaci√≥n de forma remota a otro programa que verifica si los datos bancarios son correctos. Una vez que se confirma el pago, la aplicaci√≥n remota env√≠a la informaci√≥n al sitio web del cine y le da un ¬´OK¬ª, por lo que esta p√°gina emite los tickets.\nREST (Representational State Transfer)    Es un estilo de arquitectura de software, es cualquier interfaz entre sistemas que use HTTP para obtener datos o generar operaciones sobre esos datos en todos los formatos posibles. A partir de donde podemos establecer lo siguiente:\n Todo es un recurso y viene representado por un formato. Cada recurso tiene un √∫nico identificador y es accesible mediante una URI. Para operar con un recurso usaremos los verbos de HTTP (GET, POST, PUT, DELETE, PATCH). Cada recurso puede tener m√∫ltiples representaciones (por ejemplo se podr√≠a representar mediante json, yaml, o xml). El protocolo de comunicaci√≥n se considera sin estado (cada operaci√≥n con el recurso se trata de forma totalmente aislada)  RESTful APIs    REST es el est√°ndar m√°s l√≥gico, eficiente y habitual en la creaci√≥n de APIs. Para que una API se considere RESTful debe cumplir una serie de criterios: Un Restful API es una aplicaci√≥n que usa el protocolo cliente-servidor sin estado (no se almacena la informaci√≥n del cliente entre las solicitudes) compuesta de clientes,servidores y recursos, gestionando solicitudes a trav√©s de HTTP. Debe hacer uso de hipermedios, llevado al desarrollo de p√°ginas web es lo que permite que el usuario puede navegar por el conjunto de objetos a trav√©s de enlaces HTML. En el caso de una API REST, el concepto de hipermedia explica la capacidad de una interfaz de desarrollo de aplicaciones de proporcionar al cliente y al usuario los enlaces adecuados para ejecutar acciones concretas sobre los datos. Una arquitectura basada en capas nos permite mantener una separaci√≥n de conceptos, buscando la m√°xima cohesi√≥n y el menor acoplamiento de los componentes. En este caso, la arquitectura basada en capas que vamos a desarrollar, tiene los siguientes componentes: controladores, servicio y repositorio\nControladores    Es una capa que sirve de enlace entre las vistas y los modelos, respondiendo a mecanismos que puedan ser necesitados al momento de implementar las necesidades de la aplicaci√≥n. Esta capa contiene muy poca l√≥gica y se utiliza para realizar llamadas a servicios. Se encarga de realizar comprobaciones b√°sicas de los datos devueltos por los servicios para enviar una respuesta al cliente, Recibiendo solicitudes de vista y realizando solicitudes de vistas para mostrar resultados a los usuarios. Usamos los controladores para mapear las uris (identificadores un√≠vocos de los recursos l√≥gicos o f√≠sicos usados por las tecnolog√≠as web) de entrada del API REST. En el controlador:\n Obtenemos los datos que nos entran al servidor mediante las llamadas HTTP al API REST. Los preparamos para llamar a los servicios que operan con ellos. Con el resultado devuelto, lo preparamos para ser enviado.  Servicios    Los servicios se encargan de la l√≥gica de negocio de nuestra aplicaci√≥n. En esta capa se dice que hacer con los datos (guardados en la capa de repositorio) por lo que tiene que estar conectada con la capa de repositorio. El t√©rmino l√≥gica de negocio hace referencia a la parte de un sistema que se encarga de codificar las reglas de negocio del mundo real que determinan c√≥mo la informaci√≥n puede ser creada, almacenada y cambiada. Son rutinas que realizan entrada de datos, consultas, generaci√≥n de informes. Esta capa est√° presente, espec√≠ficamente, en todo el procesamiento que se realiza detr√°s del Backend, la aplicaci√≥n visible para el usuario. Los servicios pueden llamar a otros servicios para interactuar con ellos, y por supuesto a los repositorios, que es d√≥nde se encuentran los datos de la aplicaci√≥n.\nRepositorios    En los repositorios tenemos acceso directo a los datos de la aplicaci√≥n, y desacoplan de c√≥mo se almacena esta informaci√≥n para que los servicios no tengan que conocerla. Se utiliza entre la capa de modelo y servicio. Aqu√≠ es d√≥nde se opera con los datos, se accede a ellos, se realizan los filtros necesarios y las modificaciones que necesitemos. Una vez realizada su tarea, devuelve los datos a los servicios.\n"},{"id":11,"href":"/programa-analitico/unidad-03/","title":"UNIDAD 3","parent":"Programa Anal√≠tico","content":"El cliente liviano    Desarrollo con clientes livianos, el rol de los navegadores de internet en las tecnolog√≠as actuales. HTML. Arquitectura de un navegador de internet. Aplicaciones para Web: escenarios que soluciona. HTML din√°mico: formas de generarlo. Arquitectura del servidor HTTP. Guiones (scripts). Scripting de lado del servidor. Scripting del lado del cliente. Lenguajes de scripting, generalidades. Formularios Web: qu√© son, c√≥mo funcionan. Aplicaciones HTTP. Mantenimiento de sesiones. Estructuras de memoria, y estructuras relacionales para mantener sesiones. Cabecera HTTP. Acceso a bases de datos del lado del servidor. Seguridad de sistema web, frameworks de membres√≠a. Consideraciones con barreras cortafuegos, enrutadores, proxies. Generalidades de capa de conexi√≥n segura (SSL). Firmas digitales, autoridad de internet. HTML5, escenarios que soluciona. Manejos de la visual con hojas de estilos en cascada y estilos XSLT. Javascript con Jquery.\nObjetivos espec√≠ficos     Dominar las bases de las aplicaciones basadas en internet.  "},{"id":12,"href":"/teoria-practicos/solid/","title":"Principios SOLID","parent":"Teor√≠a Trabajos Pr√°cticos","content":"¬øQu√© son los Principios SOLID?    Son un conjunto de principios aplicables a la Programaci√≥n Orientada a Objetos que, si los usas correctamente, te ayudar√°n a escribir software de calidad en cualquier lenguaje de programaci√≥n orientada a objetos. Gracias a ellos, crear√°s c√≥digo que ser√° m√°s f√°cil de leer, testear y mantener.\nLos principios en los que se basa SOLID son los siguientes:\n‚óè Principio de Responsabilidad √önica (Single Responsibility Principle)\n‚óè Principio Open/Closed (Open/Closed Principle)\n‚óè Principio de Sustituci√≥n de Liskov (Liskov Substitution Principle)\n‚óè Principio de Segregaci√≥n de Interfaces (Interface Segregation Principle)\n‚óè Principio de Inversi√≥n de Dependencias (Dependency Inversion Principle)\nEstos principios son la base de mucha literatura que encontrar√°s en torno al desarrollo de software: muchas arquitecturas se basan en ellos para proveer flexibilidad, el testing necesita confiar en ellos para poder validar partes de c√≥digo de forma independiente, y los procesos de refactorizaci√≥n ser√°n mucho m√°s sencillos si se cumplen estas reglas.\nFueron publicados por primera vez por Robert C. Martin, tambi√©n conocido como Uncle Bob, en su libro Agile Software Development: Principles, Patterns, and Practices.\n¬øQu√© beneficios aporta usar los Principios SOLID?    Las ventajas de utilizar los Principios SOLID son innumerables, ya que nos aportan todas esas caracter√≠sticas que siempre queremos ver en un software de calidad.\nEn cada uno de los principios nos iremos centrando en qu√© aportan espec√≠ficamente, pero es interesante hacer un resumen general de lo que conseguiremos con ellos:\nSoftware m√°s flexible: mejoran la cohesi√≥n disminuyendo el acoplamiento. Lo que buscamos de un buen c√≥digo es que sus clases puedan trabajar de forma independiente y que el cambio de uno afecte lo menos posible al resto. Obviamente cuando dos clases se relacionan entre s√≠ para trabajar juntas (y esto tiene que ocurrir s√≠ o s√≠), va a existir un acoplamiento entre ellas. Pero existen distintos niveles de acoplamiento, y gracias a algunos de los Principios SOLID, podemos relajar esas dependencias y hacerlas mucho m√°s flexibles a cambios.\nTe van a hacer entender mucho mejor las arquitecturas\nEsto es porque primero hace falta entender los principios sobre los que se sustentan, y los principios SOLID son muy importantes para ello.\nSimplifican la creaci√≥n de tests\nTodo esto est√° muy relacionado con los puntos anteriores: si tienes tu c√≥digo desacoplado y una buena arquitectura, los tests van a ser mucho m√°s sencillos.\nLos Principios SOLID est√°n muy interrelacionados\nEstos principios act√∫an como un todo. No es casualidad que se expliquen de forma conjunta. Y esto tiene dos consecuencias muy importantes de entender:\n‚óè Unos principios no pueden existir sin los otros\nPor ejemplo, si se tiene una clase A que tiene un acoplamiento muy fuerte con una clase B, de tal forma que cada vez que cambia B inevitablemente tiene que cambiar A. Esto es muy posible que est√© incumpliendo el Principio de Responsabilidad √önica. La forma de cumplirlo ser√≠a haciendo que cuando B cambie, A no lo haga. Y para esto, la soluci√≥n puede ser aplicar el Principio de Inversi√≥n de Dependencias. Esto es muy normal y pasa casi siempre.\nUn mismo problema se puede resolver desde dos perspectivas distintas en funci√≥n de en qu√© Principio nos enfoquemos cuando lo resolvamos. Pero el resultado ser√° el mismo.\n‚óè Al cumplir un Principio puede que est√©s incumpliendo otro\nEsto es lo m√°s dif√≠cil de aceptar: muchas veces es imposible cumplir todos los Principios a la vez. Porque al aplicar un Principio, se puede estar dando la espalda a otro. Al final lo importante es entender la potencia de cada Principio.\nPrincipio de Responsabilidad √önica (Single Responsibility Principle)    El Principio de responsabilidad √∫nica es el primero de los cinco que componen SOLID.\nEl principio de Responsabilidad √önica nos viene a decir que un objeto debe realizar una √∫nica cosa. Es muy habitual, si no prestamos atenci√≥n a esto, que acabemos teniendo clases que tienen varias responsabilidades l√≥gicas a la vez.\n¬øC√≥mo detectar si estamos violando el Principio de Responsabilidad √önica?    La respuesta a esta pregunta es bastante subjetiva. Podemos detectar situaciones en las que una clase podr√≠a dividirse en varias:\n En una misma clase est√°n involucradas dos capas de la arquitectura: esta puede ser dif√≠cil de ver sin experiencia previa. En toda arquitectura, por simple que sea, deber√≠a haber una capa de presentaci√≥n, una de l√≥gica de negocio y otra de persistencia. Si mezclamos responsabilidades de dos capas en una misma clase, ser√° un buen indicio. El n√∫mero de m√©todos p√∫blicos: Si una clase hace muchas cosas, lo m√°s probable es que tenga muchos m√©todos p√∫blicos, y que tengan poco que ver entre ellos. Detecta c√≥mo se puede agrupar para separarlos en distintas clases. Los m√©todos que usan cada uno de los campos de esa clase: si tenemos dos campos, y uno de ellos se usa en unos cuantos m√©todos y otro en otros cuantos, esto puede estar indicando que cada campo con sus correspondientes m√©todos podr√≠a formar una clase independiente. Normalmente esto estar√° m√°s difuso y habr√° m√©todos en com√∫n, porque seguramente esas dos nuevas clases tendr√°n que interactuar entre ellas. Por el n√∫mero de imports: Si necesitamos importar demasiadas clases para hacer nuestro trabajo, es posible que estemos haciendo trabajo de m√°s. Tambi√©n ayuda fijarse a qu√© paquetes pertenecen esos imports. Si vemos que se agrupan con facilidad, puede que nos est√© avisando de que estamos haciendo cosas muy diferentes. Nos cuesta testear la clase: si no somos capaces de escribir tests unitarios sobre ella, o no conseguimos el grado de granularidad que nos gustar√≠a, es momento de plantearse dividir la clase en dos. Cada vez que escribes una nueva funcionalidad, esa clase se ve afectada: si una clase se modifica a menudo, es porque est√° involucrada en demasiadas cosas. Por el n√∫mero de l√≠neas: a veces es tan sencillo como eso. Si una clase es demasiado grande, intenta dividirla en clases m√°s manejables.  En general no hay reglas de oro para estar 100% seguros, pero estos indicios ayudar√°n a detectar algunos casos donde tengas dudas.\nPrincipio Open/Closed (Open/Closed Principle)    Este principio nos dice que una entidad de software deber√≠a estar abierta a extensi√≥n, pero cerrada a modificaci√≥n. ¬øQu√© quiere decir esto? Que tenemos que ser capaces de extender el comportamiento de nuestras clases sin necesidad de modificar su c√≥digo.\nEsto nos ayuda a seguir a√±adiendo funcionalidad con la seguridad de que no afectar√° al c√≥digo existente. Nuevas funcionalidades implicar√°n a√±adir nuevas clases y m√©todos, pero en general no deber√≠a suponer modificar lo que ya ha sido escrito.\nLa forma de llegar a ello est√° muy relacionada con el punto anterior. Si las clases s√≥lo tienen una responsabilidad, podremos a√±adir nuevas caracter√≠sticas que no les afectar√°n. Esto no quiere decir que cumpliendo el primer principio se cumpla autom√°ticamente el segundo, ni viceversa.\nEl principio Open/Closed se suele resolver utilizando polimorfismo. En vez de obligar a la clase principal a saber c√≥mo realizar una operaci√≥n, delega esta a los objetos que utiliza, de tal forma que no necesita saber expl√≠citamente c√≥mo llevarla a cabo. Estos objetos tendr√°n una interfaz com√∫n que implementar√°n de forma espec√≠fica seg√∫n sus requerimientos.\n¬øC√≥mo detectar que estamos violando el principio Open/Closed?    Una de las formas m√°s sencillas para detectarlo es darnos cuenta de qu√© clases modificamos m√°s a menudo. Si cada vez que hay un nuevo requisito o una modificaci√≥n de los existentes, las mismas clases se ven afectadas, podemos empezar a entender que estamos violando este principio.\n¬øCu√°ndo debemos cumplir con este principio?    Hay que decir que a√±adir esta complejidad no siempre compensa, y como el resto de principios, s√≥lo ser√° aplicable si realmente es necesario.\nSi tienes una parte de tu c√≥digo que es propensa a cambios, se lo debe plantear de forma que un nuevo cambio impacte lo menos posible en el c√≥digo existente.\nIntentar hacer un c√≥digo 100% Open/Closed es pr√°cticamente imposible, y puede hacer que sea ilegible e incluso m√°s dif√≠cil de mantener.\nPrincipio de Sustituci√≥n de Liskov (Liskov SubstitutionPrinciple)    El principio de sustituci√≥n de Liskov nos dice que toda clase que es hija de otra clase, debe poder utilizarse como si fuese el mismo padre. Nadie deber√≠a comportarse de manera distinta si interact√∫a con la clase padre o hija.\nEsto nos obliga a asegurarnos de que los objetos en un programa deben ser capaces de ser reemplazados con instancias de subtipos de esos objetos sin alterar el programa. La primera en hablar de √©l fue B√°rbara Liskov (de ah√≠ el nombre), una reconocida ingeniera de software americana.\n¬øC√≥mo detectar que estamos violando el principio de sustituci√≥n de Liskov?    Seguro que te has encontrado con esta situaci√≥n muchas veces: creas una clase que se extiende de otra, pero de repente uno de los m√©todos te sobra, y no sabes qu√© hacer con √©l. Las opciones m√°s r√°pidas podr√≠an ser dejarlo vac√≠o, o lanzar una excepci√≥n cuando se use, asegur√°ndose de que nadie llama incorrectamente a un m√©todo que no se puede utilizar. Si un m√©todo sobrescrito no hace nada o lanza una excepci√≥n, es muy probable que est√©s violando el principio de sustituci√≥n de Liskov.\nOtra herramienta que te avisar√° f√°cilmente son los tests. Si los tests de la clase padre no funcionan para la hija, tambi√©n estar√°s violando este principio.\nPrincipio de Segregaci√≥n de Interfaces (Interface Segregation Principle)    El principio de segregaci√≥n de interfaces viene a decir que ninguna clase deber√≠a depender de m√©todos que no usa. Por tanto, cuando creemos interfaces que definan comportamientos, es importante estar seguros de que todas las clases que implementen esas interfaces vayan a necesitar y ser capaces de agregar comportamientos a todos los m√©todos. En caso contrario, es mejor tener varias interfaces m√°s peque√±as.\nLas interfaces nos ayudan a desacoplar m√≥dulos entre s√≠. Esto es as√≠ porque si tenemos una interfaz que explica el comportamiento que el m√≥dulo espera para comunicarse con otros m√≥dulos, nosotros siempre podremos crear una clase que lo implemente de modo que cumpla las condiciones.\nEl m√≥dulo que describe la interfaz no tiene que saber nada sobre nuestro c√≥digo y, sin embargo, nosotros podemos trabajar con √©l sin problemas.\nEl problema    La problem√°tica surge cuando esas interfaces intentan definir m√°s cosas de las debidas, lo que se denominan fat interfaces.\nProbablemente ocurrir√° que las clases hijas acabar√°n por no usar muchos de esos m√©todos, y habr√° que darles una implementaci√≥n. Muy habitual es lanzar una excepci√≥n, o simplemente no hacer nada. Pero si lanzamos una excepci√≥n, es m√°s que probable que el m√≥dulo que define esa interfaz use el m√©todo en alg√∫n momento, y esto har√° fallar nuestro programa. El resto de implementaciones ‚Äúpor defecto‚Äù que podamos dar, pueden generar efectos secundarios que no esperemos, y a los que s√≥lo podemos responder conociendo el c√≥digo fuente del m√≥dulo en cuesti√≥n, cosa que no nos interesa.\n¬øC√≥mo detectar que estamos violando el Principio de segregaci√≥n de interfaces?    Si al implementar una interfaz ves que uno o varios de los m√©todos no tienen sentido y te hace falta dejarlos vac√≠os o lanzar excepciones, es muy probable que est√©s violando este principio.\nPrincipio de Inversi√≥n de Dependencias (Dependency Inversion Principle)    Gracias al principio de inversi√≥n de dependencias, podemos hacer que el c√≥digo que es el n√∫cleo de nuestra aplicaci√≥n no dependa de los detalles de implementaci√≥n, como pueden ser el framework que utilices, la base de datos, c√≥mo te conectes a tu servidor, etc.\nTodos estos aspectos se especificar√°n mediante interfaces, y el n√∫cleo no tendr√° que conocer cu√°l es la implementaci√≥n real para funcionar.\nLa definici√≥n que se suele dar es:\nA. Las clases de alto nivel no deber√≠an depender de las clases de bajo nivel. Ambas deber√≠an depender de las abstracciones.\nB. Las abstracciones no deber√≠an depender de los detalles. Los detalles deber√≠an depender de las abstracciones.\nEl problema    En la programaci√≥n vista desde el modo tradicional, cuando un m√≥dulo depende de otro m√≥dulo, se crea una nueva instancia y la utiliza sin m√°s complicaciones. Esta forma de hacer las cosas, que a primera vista parece la m√°s sencilla y natural, nos va a traer bastantes problemas posteriormente, entre ellos:\n Las partes m√°s gen√©ricas de nuestro c√≥digo (lo que llamar√≠amos el dominio o l√≥gica de negocio) depender√° por todas partes de detalles de implementaci√≥n. Esto no es bueno, porque no podremos reutilizarlo, ya que estar√° acoplado al framework de turno que usemos, a la forma que tengamos de persistir los datos, etc. Si cambiamos algo de eso, tendremos que rehacer tambi√©n la parte m√°s importante de nuestro programa. No quedan claras las dependencias: si las instancias se crean dentro del m√≥dulo que las usa, es mucho m√°s dif√≠cil detectar de qu√© depende nuestro m√≥dulo y, por tanto, es m√°s dif√≠cil predecir los efectos de un cambio en uno de esos m√≥dulos. Tambi√©n nos costar√° m√°s tener claro si estamos violando algunos otros principios, como el de Responsabilidad √önica. Es muy complicado hacer tests: Si tu clase depende de otras y no tienes forma de sustituir el comportamiento de esas otras clases, no puedes testarla de forma aislada. Si algo en los tests falla, no tendr√≠as forma de saber de un primer vistazo qu√© clase es la culpable.  ¬øC√≥mo detectar que estamos violando el Principio de inversi√≥n de dependencias?    Cualquier instanciaci√≥n de clases complejas o m√≥dulos es una violaci√≥n de este principio. Adem√°s, si escribes tests te dar√°s cuenta muy r√°pido, en cuanto no puedas probar esa clase con facilidad porque dependa del c√≥digo de otra clase.\nEntonces c√≥mo vamos a hacer para darle al m√≥dulo todo lo que necesita para trabajar. Habr√° que utilizar alguna de las alternativas que existen para suministrar esas dependencias.\nAunque hay varias, las que m√°s se suelen utilizar son mediante constructor y mediante setters (funciones que lo √∫nico que hacen es asignar un valor).\n¬øQui√©n se encarga de proveer las dependencias? Lo m√°s habitual es utilizar un inyector de dependencias: un m√≥dulo que se encarga de instanciar los objetos que se necesiten y pas√°rselos a las nuevas instancias de otros objetos. Se puede hacer una inyecci√≥n muy sencilla a mano, o usar alguna de las muchas librer√≠as que existen si necesitamos algo m√°s complejo.\nConclusi√≥n    Las reglas SOLID son ideas muy potentes que generan un gran aporte para crear software de calidad, pero hay que aplicarlas donde corresponda y sin obsesionarnos con cumplirlas en cada punto del desarrollo, por eso es importante entender bien todos los conceptos para no agregar errores a futuro. Por lo tanto, concluimos en que casi siempre es m√°s sencillo limitarse a usarlas cuando nos haya surgido la necesidad real.\n"},{"id":13,"href":"/programa-analitico/unidad-04/","title":"UNIDAD 4","parent":"Programa Anal√≠tico","content":"Aplicaciones distribuidas y servicios de internet    Evoluci√≥n de los sistemas distribuidos. Desarrollo de aplicaciones distribuidas con clientes pesados y decodificadores de XML. Servicios Web en la internet. Protocolo de acceso simple a objetos SOAP. Modelo REST, Open Data Protocol, ATOM, JSON. Est√°ndares basados en el modelo REST. Generalidades de JSON y su comparaci√≥n con XML. HTML 5 Websockets. WebAPI. Conexiones long-polling, forever frame, server-sent events y websockets, ventajas y desventajas. Ejemplos de uso.\nObjetivos espec√≠ficos     Dise√±ar un sistema distribuido basado en redes p√∫blicas  "},{"id":14,"href":"/teoria-practicos/rest/","title":"REST","parent":"Teor√≠a Trabajos Pr√°cticos","content":"REpresentational State Transfer    Transferencia de estados representacionales    REST es una interfaz para conectar varios sistemas basados en el protocolo HTTP y nos sirve para obtener y generar datos y operaciones, devolviendo esos datos en formatos muy espec√≠ficos, como XML y JSON.\nREST se apoya en HTTP\nLos verbos que utiliza son exactamente los mismos, con ellos se puede hacer GET, POST, PUT y DELETE.\nVer presentaci√≥n: REST API\nPara que una API sea considerada como REST debe superar las siguientes caracter√≠sticas arquitect√≥nicas ‚óè Uso de una interfaz uniforme\n‚óè Modelo Cliente-Servidor\n‚óè Operaciones sin estado\n‚óè Almacenamiento en cach√©\n‚óè Sistema de capas\n‚óè C√≥digo de baja demanda\nRest retorna c√≥digo de status HTTP como respuesta. Los m√°s conocidos son:\n‚óè 200: Ok\n‚óè 201: Creado\n‚óè 401: Sin autorizaci√≥n\n‚óè 403: Prohibido\n‚óè 404: Recurso no encontrado\n‚óè 500: Error de servidor\n¬øPor qu√© debemos utilizar REST?    REST no es solo una moda, y es por las siguientes razones que esta interfaz est√° teniendo tanto protagonismo en los √∫ltimos a√±os:\n Crea una petici√≥n HTTP que contiene toda la informaci√≥n necesaria, es decir, un REQUEST a un servidor que almacena esa informaci√≥n y solo espera una RESPONSE. Se apoya sobre un protocolo que es el que se utiliza para las p√°ginas web, que es HTTP. Se apoya en los m√©todos b√°sicos de HTTP, como son:\n‚óã Post: Para crear recursos nuevos.\n‚óã Get: Para acceder a los distintos recursos.\n‚óã Put: Para modificar. ‚óã Patch: Para modificaciones parciales. ‚óã Delete: Para borrar un recurso o un dato, por ejemplo de nuestra base de datos. Todos los objetos se manipulan mediante URI  Ventajas de REST    Nos permite separar el cliente del servidor    Esto quiere decir que nuestro servidor se puede desarrollar en Node y Express, y nuestra API REST con Vue por ejemplo, no tiene por qu√© estar todos dentro de uno mismo.\nPosee una gran Comunidad    En la actualidad tiene una gran comunidad como proyecto en Github y en distintos lenguajes de programaci√≥n.\nIndependencia de tecnolog√≠as / lenguajes    Es totalmente independiente de la plataforma, as√≠ que podemos hacer uso de REST tanto en Windows, Linux, Mac o el sistema operativo que nosotros queramos.\nEscalabilidad, Fiabilidad, flexibilidad    Nos da escalabilidad, porque tenemos la separaci√≥n de conceptos de CLIENTE y SERVIDOR, por tanto, podemos dedicarnos exclusivamente a la parte del servidor.\nA la hora de ejecutar tu aplicaci√≥n tambi√©n tienes una flexibilidad mucho mayor. Por las caracter√≠sticas de REST (principalmente no guardar estado) es indiferente qu√© servidor atienda cada solicitud, pues es el propio cliente el que tiene que mandar el estado al servidor.\nLa escalabilidad que aporta es gracias a una serie de caracter√≠sticas que presenta la arquitectura REST:\n‚óé Es un protocolo sin estado, debido a que no se guarda la informaci√≥n en el servidor. Es decir, toda la informaci√≥n ser√° enviada por el cliente en cada mensaje HTTP, consiguiendo un ahorro en variables de sesi√≥n y almacenamiento interno del servidor.\n‚óé Presenta un conjunto de operaciones bien definidas, siendo las m√°s importantes GET, PUT, POST y DELETE, que se emplean en todos los recursos.\n‚óé Utiliza URIs √∫nicas siguiendo una sintaxis universal.\n‚óé Emplea hipermedios para representar la informaci√≥n, que suelen ser HTML, XML o JSON.\nAdicionalmente     Podemos crear un dise√±o de un microservicio orientado a un dominio (DDD) Podemos hacer nuestra API p√∫blica, permitiendo el acceso a quien quiere hacer uso de nuestra API d√°ndonos mayor visibilidad.  ¬øQui√©n usa REST?    Muchas empresas como Twitter, Facebook, Google, Netflix, LinkedIn y miles de startups y empresas usan REST. Todos estas empresas y servicios tienen su API REST por un lado con su l√≥gica de negocio y por otro lado su parte frontend, con lo cual nos permite centrarnos tambi√©n un poco m√°s en lo que es nuestra l√≥gica de negocio haciendo una API REST potente.\nDesventajas de REST     Cambiar el modo de pensar para los equipos de trabajo. Mayor tiempo de desarrollo porque hay que montar todo el sistema de la API. Requiere m√°s conocimientos. Montar una infraestructura propia. Pueden presentarse circunstancias de mayor rigidez en el desarrollo y surgir situaciones de des-sincronizaci√≥n.  Seguridad en REST API    Ver presentaci√≥n:\n Seguridad REST API  "},{"id":15,"href":"/programa-analitico/unidad-05/","title":"UNIDAD 5","parent":"Programa Anal√≠tico","content":"Frameworks de desarrollo de uso en la industria    La tecnolog√≠a .Net, Java, Golang, Rust. Similitudes y diferencias en el modelo de ejecuci√≥n. Arquitectura de las m√°quinas virtuales espec√≠ficas. Clientes pesados. Clientes livianos. Objetos de negocio. Capa de acceso a datos. Framework de persistencia. Capa de fachada web y cliente inteligente. Entornos integrados de desarrollo. Ciclos de vida de una aplicaci√≥n. Servicios de los entornos de desarrollo integrados (IDE) modernos. Servidores de integraci√≥n continua. Ciclo de vida de proyectos basado en la nube.\nObjetivos espec√≠ficos:     Familiarizarse con las grandes familias de plataformas tecnol√≥gicas en uso en la industria mundial.  "},{"id":16,"href":"/teoria-practicos/mvc/","title":"MVC","parent":"Teor√≠a Trabajos Pr√°cticos","content":"¬øQu√© es MVC (Modelo Vista Controlador)?    Es un patr√≥n de dise√±o de arquitectura de software.\nVer presentaciones:\n Patr√≥n MVC ASP.NET MVC  Modelo    El modelo contiene principalmente las entidades que representan el dominio, la logica de negocio y los mecanismos de persistencia de nuestro sistema.\nVista    En la vista encontraremos los componentes responsables de generar la interfaz con el exterior, por regla general, aunque no exclusivamente, el UI de nuestra aplicaci√≥n.\nControlador    En el controlador se encuentran los componentes capaces de procesar las interacciones del usuario, consultar o actualizar el modelo y seleccionar las vistas apropiadas en cada momento.\nVentajas     Separaci√≥n del Modelo de la Vista. Crea independencia de funcionamiento. Facilita agregar nuevos tipos de datos. Facilita el mantenimiento en caso de errores. Ofrece maneras m√°s sencillas para probar el correcto funcionamiento del sistema. Pruebas de funcionamiento m√°s sencillas. Permite el escalamiento de la aplicaci√≥n en caso de ser requerido.  Desventajas     Agrega complejidad del sistema. Incrementan los archivos a mantener y desarrollar. Aumenta la dificultad de aprendizaje  SOAP Web Services    Ver presentaci√≥n:\n SOAP Web Services  "},{"id":17,"href":"/programa-analitico/unidad-06/","title":"UNIDAD 6","parent":"Programa Anal√≠tico","content":"Las tecnolog√≠as emergentes: la Nube    Comparativa entre sistemas en la nube y sistemas sobre demanda. El software como servicio. La infraestructura como servicio. El ecosistema de desarrollo, venta de aplicaciones, entorno de ejecuci√≥n, dependencia de servicios espec√≠ficos basados en la nube: localizaci√≥n y seguimiento, licenciamiento, autenticaci√≥n y autorizaci√≥n distribuidas. Servicios en la nube para clientes convencionales y para dispositivos m√≥viles. Comparativas entre Amazon Cloud Services, Windows Azure, Google Apps, y su integraci√≥n con las IDEs correspondientes. Kuberntes y las arquitecturas de microservicios y los service mesh.\nObjetivos espec√≠ficos     Dise√±ar un sistema basado en servicios en la nube.  "},{"id":18,"href":"/teoria-practicos/node-frameworks/","title":"Frameworks en Node.js","parent":"Teor√≠a Trabajos Pr√°cticos","content":"Express.js    Express.js es el framework de Node.js m√°s utilizado. Es un framework minimalista que permite crear aplicaciones Web y APIs. Posee una arquitectura r√°pida, robusta y as√≠ncrona.\nSu API permite a los usuarios configurar rutas para enviar/recibir peticiones entre el front-end y la base de datos (actuando como un marco de trabajo del servidor HTTP). Una buena ventaja de express es que soporta muchos otros paquetes y otros motores de plantillas como Pug, Mustache, EJS y muchos m√°s.\nExpress se alinea con operaciones de E/S de alta velocidad y con la naturaleza ‚Äúsingle-threaded‚Äù (un s√≥lo hilo) de Node, haci√©ndolo casi un requerimiento por default para apps desarrolladas con Node.js.\nCaracter√≠sticas:    ‚óè Paquetes veloces del lado del servidor. Express incorpora muchas caracter√≠sticas de node como funciones que pueden acelerar el proceso con pocas l√≠neas de c√≥digo.\n‚óè Alta performance, m√∫ltiples operaciones pueden ser ejecutadas independientemente de otras utilizando programaci√≥n as√≠ncrona.\n‚óè Alta cobertura de testing.\n‚óè Gran abanico de herramientas de HTTP, lo que resulta en programas m√°s reusables y f√°ciles de entender.\n‚óè Better content negotiation- this helps in better communication between the client and server by providing HTTP headers to URLs, which fetch the exact information for the users/client-side.\nPatr√≥n MVC    Cu√°ndo usar Express.js.\nSe pueden desarrollar aplicaciones m√°s r√°pido ya que cuenta con bases disponibles para la generaci√≥n de APIs. Se puede usar en casi cualquier nivel empresarial porque tiene un enrutamiento robusto, plantillas, infraestructura de seguridad y soporte de errores.\nResulta adecuado para cualquier tipo de aplicaciones web o m√≥vil de cualquier tama√±o. Para los equipos de desarrolladores principiantes esta es el mejor framework porque cuentan con una comunidad disponible para apoyarlos.\nHapi.js    Hapi.js es un framework open-source para aplicaciones web. Es utilizado para crear servidores proxy, REST APIs y otras aplicaciones de escritorio ya que el framework es conocido por su confianza y alto contenido en todo lo que se refiera a seguridad. Tiene una basta cantidad de plugins incorporados para evitar utilizar middleware no oficial.\nCaracter√≠sticas:    ‚óè Aplicaciones escalables\n‚óè M√≠nimos gastos generales\n‚óè Medidas de seguridad por default\n‚óè Rico ecosistema\n‚óè Rapido y facil arreglo de errores\n‚óè Compatibilidad con MySQL, MongoDB y otras bases de datos\n‚óè Compatible con REST APIs y aplicaciones HTTPS proxy ‚óè Cacheo, autenticaci√≥n y validaci√≥n de entrada por default\nCu√°ndo utilizar Hapi.js    Hapi.js se puede utilizar cuando se quiere desarrollar con mayores medidas de seguridad, se desea un sistema escalable, en tiempo real y/o con aplicaciones orientadas al social-media. Los desarrolladores usualmente lo utilizan para crear servidores proxies y APIs.\nSocket.io    Socket.io es una librer√≠a de JavaScript utilizada para desarrollar aplicaciones en tiempo real y establecer una comunicaci√≥n bidireccional entre clientes y servidores. Tambi√©n es utilizado para construir aplicaciones con requerimientos de desarrollo de websocket. Por ejemplo, aplicaciones de chat como WhatsApp, que necesitan estar funcionando continuamente y actualizando su contenido en tiempo real, recargando los procesos de fondo para capturar las actualizaciones o mensajes. Tambi√©n ofrece an√°lisis de la aplicaci√≥n en tiempo real con unas pocas l√≠neas de c√≥digo. M√°s de mil compa√±√≠as, incluidas Bepro, Barogo y Patreon utilizan esta librer√≠a.\nCaracter√≠sticas:    ‚óè Soporte binario (con una librer√≠a del lado del cliente y otra del lado del servidor)\n‚óè Soporte de multiplexaci√≥n\n‚óè Confiabilidad\n‚óè Soporte de auto-reconexi√≥n\n‚óè Detecci√≥n de errores y autocorrecci√≥n\n‚óè Similar APIs for a client and server-side development\nCu√°ndo utilizar Socket.io    Socket.io permite desarrollar aplicaciones en tiempo real en las que los servidores necesitan enviar datos sin ser √©stos requeridos por el lado del cliente (aplicaciones de chat, de videoconferencias, juegos multijugador)\nSails.js    Sails.js se asemeja a la arquitectura MVC con patrones vistos en otros frameworks como Ruby on Rails y provee soporte para un desarrollo moderno y orientado a los datos. Es compatible con todas las bases de datos y flexible integrando frameworks de Javascript. Las APIs est√°n basadas en datos, con una arquitectura escalable orientada a servicios.\nEs muy pr√°ctico para crear aplicaciones customizadas de alto nivel. Sus pol√≠ticas para la escritura de c√≥digo ayudan a reducir la cantidad necesitada de c√≥digo, permitiendo la integraci√≥n con m√≥dulos NPM al ser m√°s flexible y abierto.\nSi bien es una plataforma con un frontend-agnostic-backend, este framework utiliza Express para lo que son las request HTTP y Socket.io para los WebSockets\nTambi√©n permite compartir la misma API utilizada por otro servicio web u otro equipo de desarrollo, lo cual ayuda disminuyendo los tiempos y el esfuerzo. Sails agrupa un ORM, que hace posible la compatibilidad con casi todas las bases de datos, llegando incluso a proporcionar un gran n√∫mero de proyectos comunitarios. Algunos de sus adaptadores oficialmente soportados incluyen MYSQL, MongoDB, PostgreSQL, Redis, e incluso Local Disk.\nCaracter√≠sticas:    ‚óè REST APIs auto-generadas\n‚óè Pol√≠ticas de seguridad reutilizables\n‚óè Backend agn√≥stico (el framework es independiente de cualquier frontend)\n‚óè ORM (Object Relational Mapping) compatible con integraci√≥n de base de datos de Express para las request HTTP y de Socket.io para WebSockets. Cuando utilizar Sails.js\nDebido a su precisi√≥n, simplificaci√≥n de datos y funciones middleware reutilizables, se puede construir aplicaciones de chat customizadas con este framework.\nPosee una excelente compatibilidad con Socket.io, haci√©ndolo muy √∫til para aplicaciones como juegos y de redes sociales. Sails.js tambi√©n es muy com√∫n para aplicaciones Node.js customizadas a escala empresarial.\nSe pueden producir apps listas para producci√≥n en cuesti√≥n de semanas, adem√°s se asemeja al patr√≥n de arquitectura MVC utilizado en Ruby on Rails. Sin embargo, no es muy utilizado para la creaci√≥n de peque√±as apps. Esto se debe a que Sails tiene algunas limitaciones en su flexibilidad cuando se trata de personalizaciones de alto nivel como con Express.\n    Express.js Hapi.js Socket.io Sails.js     Performance R√°pido Media - alta Media. Se vuelve lenta cuando se escala Media. Se enfoca en mejorar la eficiencia del desarrollador por sobre la performance   Soporte de la comunidad Masivo. Posee una comunidad donde se manejan un mont√≥n de preguntas y respuestas Amplio soporte, posee una gran comunidad en github Soporte amplio Gran soporte, ya que es un framework bien establecido desde hace bastante tiempo   Facilidad de uso Depende la dificultad del proyecto, generalmente sencillo de aprender F√°cil. Posee una amplia cantidad de plugins que facilitan su uso F√°cil porque requiere que el programador sepa solo del framework F√°cil porque cuenta con blueprints que hacen m√°s f√°cil conectar las APIs con un c√≥digo minimal   Mejor para Peque√±os y grandes proyectos. Tambi√©n es una buena forma de aprender c√≥mo trabajar con Node Ideal para crear aplicaciones seguras, en tiempo real y escalables Generalmente usada en aplicaciones en tiempo real o apps que requieran un chat en vivo o sala de conferencias Proyectos medianos que necesitan implementarse r√°pido    "},{"id":19,"href":"/categories/","title":"Categories","parent":"Fundamentaci√≥n","content":""},{"id":20,"href":"/","title":"Fundamentaci√≥n","parent":"","content":"La asignatura Desarrollo de Aplicaciones Cliente Servidor ha dado, en su dictado de m√°s de una d√©cada, un contacto intenso con las herramientas de uso normal en la industria para el desarrollo y la ingenier√≠a de software. En la actualidad estos conceptos generales siguen siendo v√°lidos, pero han cambiado significativamente los detalles subyacentes en el dise√±o, programaci√≥n, prueba, despliegue y mantenimiento de una aplicaci√≥n cliente-servidor. El tr√°fico de internet generado por dispositivos t√°ctiles y m√≥viles es mayor que el de equipos de escritorio, y la introducci√≥n las nueves de datos fuerzan al ingeniero a dominar una nueva forma de crear aplicaciones altamente conectadas. Las tecnolog√≠as cliente-servidor han mutado, mayor mente desde un modelo monol√≠tico a un modelo distribuido de micro-servicios, basado en infraestructuras basadas en contenedores, posibilitando el escalamiento horizontal. Un importante porcentaje de c√≥digo de cualquier aplicaci√≥n est√° relacionado con la administraci√≥n de conectividad de datos sobre redes p√∫blicas, y por lo tanto se hace mandatorio enfocarse en los est√°ndares emergentes y abiertos basados en internet, tanto en el cliente como en la infraestructura del servidor.\nLa adopci√≥n de los lenguajes de programaci√≥n tambi√©n han cambiado significativamente, pasando de lenguajes como javascript y golang, haciendo que los frameworks de ejecuci√≥n cambien significativamente. Esto incluye servicios de soporte al ciclo de vida de una aplicaci√≥n, desde el dise√±o hasta el mantenimiento de la misma, tanto en los modelos on-premise, como los basados en la nube. Igualmente, los sistemas convergentes son una realidad, al borrarse los l√≠mites entre los sistemas m√≥viles y de escritorio, las t√©cnicas de desarrollo tambi√©n han mutado. Es evidente que semejante raz√≥n de cambio exige una materia de orientaci√≥n eminentemente pr√°ctica y con contenido puesto al d√≠a, contemplando los conceptos tradicionales de la ingenier√≠a de software cliente-servidor, pero haciendo √©nfasis pr√°ctico en los est√°ndares emergentes de estos nuevos modelos, sobre todo en las nuevas tecnolog√≠as convergentes.\nObjetivos Generales de la asignatura     Que el alumno profundice los conocimientos en el an√°lisis, dise√±o y desarrollo de aplicaciones en la met√°fora cliente-servidor. Que el alumno aplique las herramientas que el mercado ofrece para crear soluciones √∫tiles a problemas reales, produciendo sistemas de alto rendimiento. Que el alumno tenga acceso a tecnolog√≠as de √∫ltima generaci√≥n. Que el alumno pueda desarrollar aplicaciones utilizando tecnolog√≠as emergentes, como ser la computaci√≥n en la nube.  "},{"id":21,"href":"/programa-analitico/","title":"Programa Anal√≠tico","parent":"Fundamentaci√≥n","content":"UNIDAD 1: Introducci√≥n a las aplicaciones cliente-servidor    Repaso de las arquitecturas m√°s comunes en sistemas distribuidos. Modelo de capas. Dos y tres capas. Modelo de tres capas, la tendencia actual. Modelo distribuido y de microservices, introducci√≥n. Interfaces de acceso a los datos: ODBC, OLE DB y los objetos ADO. JDBC. Publicadores y consumidores de datos. Patrones de dise√±o en arquitecturas distribuidas, Event-Sourcing.\nObjetivos espec√≠ficos     Discriminar las diferencias conceptuales entre las distintas tecnolog√≠as existentes.  "},{"id":22,"href":"/tags/","title":"Tags","parent":"Fundamentaci√≥n","content":""},{"id":23,"href":"/teoria-practicos/","title":"Teor√≠a Trabajos Pr√°cticos","parent":"Fundamentaci√≥n","content":"Sistemas de Control de Versionado    Acceso a Datos    ORM / ODM    Patrones Acceso a Datos    "},{"id":24,"href":"/trabajos-practicos/","title":"Trabajos Pr√°cticos","parent":"Fundamentaci√≥n","content":""}]